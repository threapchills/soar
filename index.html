<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Wizard Carpet Quest</title>
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no, viewport-fit=cover">
<link rel="icon" type="image/png" href="assets/wizard_shoot.png">
<style>
  :root { --ui-fade: 0.35 }
  html, body { height:100%; }
  body { margin:0; overflow:hidden; background:black; touch-action:none; }
  canvas { display:block; background:black; width:100vw; height:100vh; }

  /* Mobile HUD (hidden on non-touch) */
  .hud { position:fixed; inset:0; pointer-events:none; display:none; }
  .touch .hud { display:block; }
  .stick {
    position: fixed;
    width: 140px; height: 140px; border-radius: 50%;
    background: radial-gradient(circle at 50% 50%, rgba(255,255,255,0.08), rgba(255,255,255,0.02));
    border: 1px solid rgba(255,255,255,0.2);
    pointer-events:auto; opacity: var(--ui-fade);
  }
  .pad {
    position:absolute; left:50%; top:50%; transform:translate(-50%,-50%);
    width: 70px; height:70px; border-radius:50%;
    background: rgba(255,255,255,0.15); border:1px solid rgba(255,255,255,0.3);
  }
  .left-stick { left: 20px; bottom: 24px; }
  .right-stick { right: 20px; bottom: 24px; }
</style>
</head>
<body>
<canvas id="game"></canvas>
<div class="hud" id="hud">
  <div class="stick left-stick" id="stickL"><div class="pad" id="padL"></div></div>
  <div class="stick right-stick" id="stickR"><div class="pad" id="padR"></div></div>
</div>

<script>
/* ========= Canvas & DPI ========= */
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
function resizeCanvas(){
  const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1)); // cap at 2x for perf
  const w = Math.floor(window.innerWidth);
  const h = Math.floor(window.innerHeight);
  canvas.style.width = w + 'px';
  canvas.style.height = h + 'px';
  canvas.width = Math.floor(w * dpr);
  canvas.height = Math.floor(h * dpr);
  ctx.setTransform(dpr,0,0,dpr,0,0); // use CSS pixels as logical units
}
resizeCanvas();
window.addEventListener('resize', resizeCanvas);

/* ========= Input (desktop) ========= */
let keys = {};
let mouse = { x: window.innerWidth/2, y: window.innerHeight/2, down: false };
window.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true, {passive:false});
window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false, {passive:false});
window.addEventListener('mousemove', e => { mouse.x = e.clientX; mouse.y = e.clientY; }, {passive:true});
window.addEventListener('mousedown', () => mouse.down = true, {passive:false});
window.addEventListener('mouseup', () => mouse.down = false, {passive:false});

/* ========= Touch detection & dual sticks ========= */
const isTouch = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
if (isTouch) document.documentElement.classList.add('touch');
const hud = document.getElementById('hud');
const stickL = document.getElementById('stickL'), padL = document.getElementById('padL');
const stickR = document.getElementById('stickR'), padR = document.getElementById('padR');

let leftStick = { active:false, dx:0, dy:0 };
let rightStick = { active:false, dx:0, dy:0 };

function stickBounds(el){ const r = el.getBoundingClientRect(); return {x:r.left + r.width/2, y:r.top + r.height/2, rad: r.width*0.5}; }
function handleStickTouch(e){
  e.preventDefault();
  const touches = e.touches ? Array.from(e.touches) : [];
  leftStick.active = rightStick.active = false; leftStick.dx=leftStick.dy=rightStick.dx=rightStick.dy=0;

  const lb = stickBounds(stickL), rb = stickBounds(stickR);
  touches.forEach(t=>{
    const x=t.clientX, y=t.clientY;
    const dl = Math.hypot(x-lb.x, y-lb.y);
    const dr = Math.hypot(x-rb.x, y-rb.y);
    if (dl < lb.rad) {
      leftStick.active = true;
      const ang = Math.atan2(y-lb.y, x-lb.x);
      const mag = Math.min(1, dl/lb.rad);
      leftStick.dx = Math.cos(ang)*mag;
      leftStick.dy = Math.sin(ang)*mag;
      padL.style.transform = `translate(${(leftStick.dx*lb.rad*0.4)}px, ${(leftStick.dy*lb.rad*0.4)}px)`;
    } else if (dr < rb.rad) {
      rightStick.active = true;
      const ang = Math.atan2(y-rb.y, x-rb.x);
      const mag = Math.min(1, dr/rb.rad);
      rightStick.dx = Math.cos(ang)*mag;
      rightStick.dy = Math.sin(ang)*mag;
      padR.style.transform = `translate(${(rightStick.dx*rb.rad*0.4)}px, ${(rightStick.dy*rb.rad*0.4)}px)`;

      // Aim vector => synthetic mouse
      mouse.x = player ? player.x + Math.cos(ang)*300 : x;
      mouse.y = player ? player.y + Math.sin(ang)*300 : y;
      mouse.down = mag > 0.2; // hold to shoot (deadzone)
    }
  });

  // Map left stick to WSAD booleans
  keys['w'] = leftStick.active && (leftStick.dy < -0.3);
  keys['s'] = leftStick.active && (leftStick.dy >  0.3);
  keys['a'] = leftStick.active && (leftStick.dx < -0.3);
  keys['d'] = leftStick.active && (leftStick.dx >  0.3);

  if (!rightStick.active) { mouse.down = false; padR.style.transform='translate(-50%,-50%)'; }
  if (!leftStick.active)  { padL.style.transform='translate(-50%,-50%)'; }
}
if (isTouch) {
  ['touchstart','touchmove','touchend','touchcancel'].forEach(evt=>{
    window.addEventListener(evt, handleStickTouch, {passive:false});
  });
}

/* ========= Assets ========= */
function loadImage(src) { const img = new Image(); img.src = src; return img; }
const bgLayers = [
  loadImage('assets/bg0.png'), // static sky
  loadImage('assets/bg1.png'),
  loadImage('assets/bg2.png'),
  loadImage('assets/bg3.png')
];
const wizardFly = loadImage('assets/wizard_fly.png');
const wizardShoot = loadImage('assets/wizard_shoot.png');
const enemiesSprites = [
  loadImage('assets/enemy1.png'),
  loadImage('assets/enemy2.png'),
  loadImage('assets/enemy3.png')
];
const orbSprite = loadImage('assets/orb.png');
const heartSprite = loadImage('assets/heart.png');

const song = new Audio('assets/song.ogg'); song.loop = true; song.volume = 0.0;
const sfxShoot = new Audio('assets/shoot.wav');
const sfxHit = new Audio('assets/hit.wav');
const sfxPickup = new Audio('assets/pickup.wav');

let shootAudioCtx = null;
let shootBufferPromise = null;
const shootVariantBuffers = {};

/* ========= Game State ========= */
let started=false, gameOver=false, cameraShake=0;
let bgHue=0, bgHueTimer=0;
let dayHue=0, worldBrightness=1, timeOfDay=0, dayCycle=120*60;
let weather='clear', weatherTimer=0, weatherParticles=[], lightningFlash=0;
let player, projectiles, enemies, particles, collectables, effects, floatTexts, enemySpawnTimer, boss, bossProjectiles, bossSigils, bossHazards, bossSpawnTimer, killCount, clones, bossDropTimer;
bossSigils = [];
bossHazards = [];
clones = [];
let lastTime = 0, frameDt = 1;


const hueMap = {
  fire: 0,
  lightning: 220,
  ice: 180,
  rapid: 310,
  fury: 40,
  focus: 120,
  bomb: 300
};

const weaponDefinitions = {
  default: {
    label: 'Arcane Bolt',
    color: '255,255,150',
    levels: [
      { cooldown: 15, speed: 10, damage: 1.1, spread: 0.12, shots: 1, pierce: 0, size: 6, life: 70 },
      { cooldown: 13, speed: 11, damage: 1.2, spread: 0.1,  shots: 1, pierce: 1, size: 6, life: 80 },
      { cooldown: 11, speed: 12, damage: 1.35, spread: 0.08, shots: 2, pierce: 1, size: 7, life: 90 }
    ]
  },
  fire: {
    label: 'Ember Nova',
    color: '255,140,60',
    levels: [
      { cooldown: 24, speed: 6.2, damage: 2.1, spread: 0.07, shots: 1, burnDuration: 160, burnDps: 0.03, aoeRadius: 0, size: 7 },
      { cooldown: 22, speed: 6.5, damage: 2.3, spread: 0.09, shots: 1, burnDuration: 180, burnDps: 0.05, aoeRadius: 55, size: 7 },
      { cooldown: 20, speed: 6.8, damage: 2.5, spread: 0.12, shots: 2, burnDuration: 210, burnDps: 0.07, aoeRadius: 70, size: 8 }
    ]
  },
  lightning: {
    label: 'Storm Lance',
    color: '150,210,255',
    levels: [
      { cooldown: 30, damage: 2.4, chain: 2, chainFalloff: 0.75, shockDuration: 35 },
      { cooldown: 26, damage: 2.6, chain: 3, chainFalloff: 0.8, shockDuration: 45 },
      { cooldown: 22, damage: 3.0, chain: 4, chainFalloff: 0.85, shockDuration: 55, stormForks: 2 }
    ]
  },
  ice: {
    label: 'Frost Shard',
    color: '160,220,255',
    levels: [
      { cooldown: 22, speed: 8.2, damage: 1.2, spread: 0.08, shots: 1, slowDuration: 150, chillFactor: 0.5, size: 6 },
      { cooldown: 20, speed: 8.5, damage: 1.35, spread: 0.1,  shots: 1, slowDuration: 180, chillFactor: 0.45, size: 6, splinter: 1 },
      { cooldown: 18, speed: 9.0, damage: 1.45, spread: 0.11, shots: 2, slowDuration: 210, chillFactor: 0.4, size: 7, splinter: 2 }
    ]
  }
};

const powerUpDefinitions = {
  rapid: {
    label: 'Rapid Fire',
    duration: 480,
    apply(stats){ stats.cooldown *= 0.75; }
  },
  fury: {
    label: 'Arcane Fury',
    duration: 420,
    apply(stats){ stats.damage *= 1.35; stats.aoeRadius = (stats.aoeRadius||0) + 20; }
  },
  focus: {
    label: 'Focus Sigil',
    duration: 540,
    apply(stats){ stats.spread *= 0.5; stats.pierce = (stats.pierce||0) + 1; stats.shots = (stats.shots||1); }
  },
  overdrive: {
    label: 'Overdrive Glyph',
    duration: 360,
    apply(stats){ stats.shots = (stats.shots||1) + 1; stats.damage *= 1.15; }
  }
};

const collectableVisuals = {
  heart: { sprite: heartSprite },
  fire: { sprite: orbSprite, hue: hueMap.fire },
  lightning: { sprite: orbSprite, hue: hueMap.lightning },
  ice: { sprite: orbSprite, hue: hueMap.ice },
  rapid: { sprite: orbSprite, hue: hueMap.rapid, glow: 'rgba(255,120,255,0.55)' },
  fury: { sprite: orbSprite, hue: hueMap.fury, glow: 'rgba(255,180,90,0.55)' },
  focus: { sprite: orbSprite, hue: hueMap.focus, glow: 'rgba(150,255,180,0.55)' },
  overdrive: { sprite: orbSprite, hue: 260, glow: 'rgba(200,170,255,0.55)' },
  bomb: { sprite: orbSprite, hue: hueMap.bomb, glow: 'rgba(255,140,220,0.6)' },
  mirror: { sprite: orbSprite, hue: 200, glow: 'rgba(150,150,255,0.55)' },
  shadows: { sprite: orbSprite, hue: 260, glow: 'rgba(210,120,255,0.6)' }
};

const shootSoundProfiles = {
  default: { playbackRate: 1.0, volume: 0.65, filter: { type: 'peaking', frequency: 1100, gain: 3 } },
  fire: { playbackRate: 0.92, volume: 0.72, filter: { type: 'lowshelf', frequency: 650, gain: 8 } },
  lightning: { playbackRate: 1.35, volume: 0.62, filter: { type: 'bandpass', frequency: 1600, q: 3.4 } },
  ice: { playbackRate: 1.12, volume: 0.58, filter: { type: 'highshelf', frequency: 2000, gain: 6 } },
  bomb: { playbackRate: 0.7, volume: 0.82, filter: { type: 'lowshelf', frequency: 320, gain: 9 } },
  missile: { playbackRate: 0.82, volume: 0.7, reverse: true, filter: { type: 'bandpass', frequency: 900, q: 4 } },
  bounce: { playbackRate: 0.88, volume: 0.68, filter: { type: 'notch', frequency: 780, q: 5 } },
  clone: { playbackRate: 1.05, volume: 0.46, filter: { type: 'highshelf', frequency: 2200, gain: 4 } }
};

function getShootAudioContext(){
  if (!shootAudioCtx){
    const Ctx = window.AudioContext || window.webkitAudioContext;
    if (Ctx){
      shootAudioCtx = new Ctx();
    }
  }
  if (shootAudioCtx && shootAudioCtx.state==='suspended'){
    shootAudioCtx.resume().catch(()=>{});
  }
  return shootAudioCtx;
}

function decodeShootBuffer(ctx, arrayBuffer){
  return new Promise((resolve, reject)=>{
    if (!ctx || !arrayBuffer) return reject('no audio context');
    ctx.decodeAudioData(arrayBuffer.slice(0), resolve, reject);
  });
}

function loadShootBuffer(){
  if (!shootBufferPromise){
    const ctx = getShootAudioContext();
    if (!ctx) return null;
    shootBufferPromise = fetch('assets/shoot.wav')
      .then(res=>res.arrayBuffer())
      .then(buf=>decodeShootBuffer(ctx, buf))
      .catch(err=>{ console.warn('Shoot sample failed', err); shootBufferPromise=null; return null; });
  }
  return shootBufferPromise;
}

function getVariantBuffer(ctx, baseBuffer, key){
  if (!baseBuffer) return null;
  const profile = shootSoundProfiles[key] || shootSoundProfiles.default;
  if (!profile || !profile.reverse) return baseBuffer;
  const cacheKey = `${key}-rev`;
  if (!shootVariantBuffers[cacheKey]){
    const rev = ctx.createBuffer(baseBuffer.numberOfChannels, baseBuffer.length, baseBuffer.sampleRate);
    for (let ch=0; ch<baseBuffer.numberOfChannels; ch++){
      const src = baseBuffer.getChannelData(ch);
      const dst = rev.getChannelData(ch);
      for (let i=0, j=src.length-1; i<src.length; i++, j--){
        dst[i] = src[j];
      }
    }
    shootVariantBuffers[cacheKey] = rev;
  }
  return shootVariantBuffers[cacheKey];
}

function playShootSound(type='default', opts={}){
  const profile = shootSoundProfiles[type] || shootSoundProfiles.default;
  const ctx = getShootAudioContext();
  if (!ctx){
    sfxShoot.currentTime = 0;
    sfxShoot.playbackRate = profile?.playbackRate || 1;
    sfxShoot.volume = opts.volume ?? profile?.volume ?? 0.65;
    sfxShoot.play().catch(()=>{});
    return;
  }
  const bufferPromise = loadShootBuffer();
  if (!bufferPromise){
    sfxShoot.currentTime = 0;
    sfxShoot.playbackRate = profile?.playbackRate || 1;
    sfxShoot.volume = opts.volume ?? profile?.volume ?? 0.65;
    sfxShoot.play().catch(()=>{});
    return;
  }
  bufferPromise.then(buffer=>{
    if (!buffer) return;
    const source = ctx.createBufferSource();
    source.buffer = getVariantBuffer(ctx, buffer, type) || buffer;
    source.playbackRate.value = profile?.playbackRate || 1;
    const gainNode = ctx.createGain();
    gainNode.gain.value = opts.volume ?? profile?.volume ?? 0.65;
    let lastNode = source;
    if (profile?.filter){
      const filter = ctx.createBiquadFilter();
      filter.type = profile.filter.type || 'lowpass';
      filter.frequency.value = profile.filter.frequency || 1200;
      if (profile.filter.q) filter.Q.value = profile.filter.q;
      if (profile.filter.gain !== undefined) filter.gain.value = profile.filter.gain;
      lastNode.connect(filter);
      lastNode = filter;
    }
    lastNode.connect(gainNode);
    gainNode.connect(ctx.destination);
    source.start(0);
  }).catch(()=>{
    sfxShoot.currentTime = 0;
    sfxShoot.playbackRate = profile?.playbackRate || 1;
    sfxShoot.volume = opts.volume ?? profile?.volume ?? 0.65;
    sfxShoot.play().catch(()=>{});
  });
}

/* ========= Start / Music ========= */
function startGame(){
  if (!started) { started=true; fadeInMusic(); resetGame(); }
  else if (gameOver) { resetGame(); }
  getShootAudioContext();
  loadShootBuffer();
}
function fadeInMusic(){
  song.currentTime=0;
  song.play().catch(()=>{});
  let vol=0;
  const fade = setInterval(()=>{
    vol += 0.02; song.volume = Math.min(vol, 0.4);
    if (song.volume >= 0.4) clearInterval(fade);
  },100);
}
window.addEventListener('click', startGame, {passive:true});
window.addEventListener('keydown', startGame, {passive:true});
window.addEventListener('touchstart', startGame, {passive:true});

function setWeather(){
  const types=['clear','rain','snow','sand','wind'];
  weather = types[Math.floor(Math.random()*types.length)];
  weatherTimer = 600 + Math.random()*1200;
}

function setTempestWeather(){
  weather = 'tempest';
  weatherTimer = 900;
  weatherParticles = [];
  lightningFlash = 10;
}

/* ========= Classes ========= */
class Background{
  constructor(img,speed,hueMult=1,baseHue=0){ this.img=img; this.speed=speed; this.x=0; this.hueMult=hueMult; this.baseHue=baseHue; }
  update(dir,dt){

    if (this.speed===0) return; // bg0 static
    this.x -= this.speed * (dir>=0 ? 1 : -1) * dt; // reverse cosmetically when moving left
    const w = window.innerWidth;
    if (this.x <= -w) this.x += w;
    if (this.x >=  w) this.x -= w;
  }
  draw(){
    const w = window.innerWidth, h = window.innerHeight;
    ctx.save();
    const hue = this.baseHue + dayHue + bgHue * this.hueMult;
    ctx.filter = `hue-rotate(${hue}deg) brightness(${worldBrightness})`;
    ctx.drawImage(this.img, this.x, 0, w, h);
    if (this.speed!==0){
      ctx.drawImage(this.img, this.x + w, 0, w, h);
      ctx.drawImage(this.img, this.x - w, 0, w, h);
    }
    ctx.restore();
  }
}

class Player{
  constructor(){
    this.x = window.innerWidth/4;
    this.y = window.innerHeight/2;
    this.width=64; this.height=32;
    this.vx=0; this.vy=0; this.accel=0.4; this.maxSpeed=5;
    this.bob=0; this.flip=false;
    this.hp=5; this.invuln=0;
    this.bonusShots=0;
    this.weapon='default';
    this.weaponLevels = { default: 0, fire: -1, lightning: -1, ice: -1 };
    this.powerUps=[];
    this.cooldownTimer=0;
    this.cachedProfile=null;
    this.bombs=2;
    this.maxBombs=6;
    this.bombCooldown=0;
    this.bombHeld=false;
    this.bombRegenTimer=220;
  }
  getWeaponProfile(){
    const def = weaponDefinitions[this.weapon] || weaponDefinitions.default;
    const maxIdx = def.levels.length-1;
    const tier = this.weaponLevels[this.weapon];
    const idx = Math.max(0, Math.min(maxIdx, tier!==undefined ? Math.max(tier,0) : 0));
    const base = def.levels[idx] || def.levels[0];
    const stats = Object.assign({
      cooldown: 15,
      speed: 9,
      damage: 1,
      spread: 0.1,
      shots: 1,
      pierce: 0,
      size: 6,
      life: 70
    }, base);
    stats.element = this.weapon;
    stats.color = def.color;
    stats.label = def.label;
    this.powerUps.forEach(p=>{
      const pow = powerUpDefinitions[p.type];
      if (pow && typeof pow.apply==='function') pow.apply(stats);
    });
    stats.cooldown = Math.max(6, stats.cooldown || 15);
    stats.spread = stats.spread===undefined ? 0.1 : stats.spread;
    stats.shots = Math.max(1, Math.round((stats.shots||1) + (this.bonusShots||0)));
    stats.pierce = Math.max(0, Math.round(stats.pierce || 0));
    this.cachedProfile = stats;
    return stats;
  }
  updatePowerUps(dt){
    for (let i=this.powerUps.length-1;i>=0;i--){
      const p=this.powerUps[i];
      p.timer-=dt;
      if (p.timer<=0) this.powerUps.splice(i,1);
    }
  }
  applyPowerUp(type){
    const def = powerUpDefinitions[type];
    if (!def) return;
    const existing = this.powerUps.find(p=>p.type===type);
    if (existing) existing.timer = def.duration;
    else this.powerUps.push({ type, timer: def.duration });
    floatTexts.push(new FloatText(this.x-40, this.y-60, def.label, '#ffd27f'));
  }
  upgradeWeapon(type){
    const def = weaponDefinitions[type];
    if (!def) return;
    if (this.weaponLevels[type] === undefined) this.weaponLevels[type] = -1;
    if (this.weaponLevels[type] < 0){
      this.weaponLevels[type] = 0;
      floatTexts.push(new FloatText(this.x-80, this.y-80, `${def.label}`, '#ffe6ff'));
    } else if (this.weaponLevels[type] < def.levels.length-1){
      this.weaponLevels[type]++;
      floatTexts.push(new FloatText(this.x-80, this.y-80, `${def.label} Lv.${this.weaponLevels[type]+1}`, '#ffe6ff'));
    } else {
      this.applyPowerUp('overdrive');
    }
    this.weapon = type;
    this.cooldownTimer = 0;
  }
  tryBomb(){
    if (this.bombs<=0 || this.bombCooldown>0) return;
    const profile = this.cachedProfile || this.getWeaponProfile();
    this.bombs--;
    this.bombCooldown = 36;
    this.bombRegenTimer = 260;
    const cx = this.x+this.width/2;
    const cy = this.y;
    effects.push(new ArcaneBomb(cx, cy, profile));
    effects.push(new SigilMissile(cx, cy-24, { damage: profile.damage||2, element: profile.element }));
    effects.push(new SigilMissile(cx, cy+24, { damage: (profile.damage||2)*0.9, element: profile.element, delay: 8 }));
    spawnBouncingOrbs(cx, cy, 3, profile);
    floatTexts.push(new FloatText(this.x-30, this.y-110, 'Arcane Salvo!', '#ff9cf0'));
    cameraShake = Math.max(cameraShake, 16);
    playShootSound('bomb');
    playShootSound('missile', { volume: 0.55 });
  }
  update(dt){
    this.updatePowerUps(dt);
    if (this.invuln>0) this.invuln -= dt;
    let tx=0, ty=0;
    if (keys['w']) ty -= this.accel*dt;
    if (keys['s']) ty += this.accel*dt;
    if (keys['a']) { tx -= this.accel*dt; this.flip = true; }
    if (keys['d']) { tx += this.accel*dt; this.flip = false; }
    this.vx = (this.vx + tx) * Math.pow(0.9, dt);
    this.vy = (this.vy + ty) * Math.pow(0.9, dt);
    this.vx = Math.max(-this.maxSpeed, Math.min(this.maxSpeed, this.vx));
    this.vy = Math.max(-this.maxSpeed, Math.min(this.maxSpeed, this.vy));
    this.x += this.vx*dt; this.y += this.vy*dt;

    // Horizontal wrap; vertical clamped
    const halfW=this.width/2, halfH=this.height/2;
    if (this.x < -halfW) this.x = window.innerWidth + halfW;
    if (this.x > window.innerWidth + halfW) this.x = -halfW;
    this.y = Math.max(halfH, Math.min(window.innerHeight - halfH, this.y));

    // bob
    this.bob += 0.05*dt; this.y += Math.sin(this.bob)*0.3*dt;

    const profile = this.getWeaponProfile();
    // shooting with cooldown
    if (mouse.down && this.cooldownTimer<=0){
      this.shoot(profile);
      this.cooldownTimer = profile.cooldown;
    }
    if (this.cooldownTimer>0) this.cooldownTimer -= dt;
    if (this.bombCooldown>0) this.bombCooldown-=dt;
    if (this.bombs < this.maxBombs){
      this.bombRegenTimer -= dt;
      if (this.bombRegenTimer <= 0){
        this.bombs++;
        this.bombRegenTimer = 260;
        floatTexts.push(new FloatText(this.x-20, this.y-120, 'Bomb Recharged', '#ffb0ff'));
      }
    } else {
      this.bombRegenTimer = 220;
    }

    const bombPressed = keys[' '] || keys['e'];
    if (bombPressed && !this.bombHeld){ this.tryBomb(); this.bombHeld=true; }
    if (!bombPressed) this.bombHeld=false;
  }
  shoot(profile){
    const angle = Math.atan2(mouse.y - this.y, mouse.x - this.x);
    const shots = Math.max(1, profile.shots || 1);
    playShootSound(profile.element || 'default');
    if (this.weapon==='lightning'){
      for(let i=0;i<shots;i++){
        const spread = (i-(shots-1)/2)*(profile.spread || 0.08);
        effects.push(new LightningEffect(this.x+this.width/2, this.y, angle+spread, profile));
      }
    } else {
      for(let i=0;i<shots;i++){
        const spread = (i-(shots-1)/2)*(profile.spread || 0.08);
        projectiles.push(new Projectile({
          x: this.x+this.width/2,
          y: this.y,
          angle: angle+spread,
          stats: profile
        }));
      }
    }
    clones.forEach(clone=>clone.shoot(profile, angle));
    for (let i=0;i<8;i++) particles.push(makeParticle(this.x+this.width/2, this.y, profile.color || '255,220,150', 2));
    cameraShake = Math.max(cameraShake,2.2);
  }
  takeDamage(){ if (this.invuln>0) return; this.hp--; this.invuln=30; this.bonusShots=0; if (this.hp<=0) gameOver=true; }
  draw(){
    const profile = this.cachedProfile || this.getWeaponProfile();
    ctx.save();
    ctx.translate(this.x, this.y);
    if (this.flip){ ctx.scale(-1,1); ctx.translate(-this.width, 0); }
    if (this.invuln%6<3){
      const img = (mouse.down && this.cooldownTimer > profile.cooldown/2) ? wizardShoot : wizardFly;
      ctx.drawImage(img, 0, -this.height/2, this.width, this.height);
    }
    ctx.restore();
    // HP UI
    ctx.fillStyle='red'; ctx.fillRect(20,20, this.hp*30, 10);
    ctx.strokeStyle='white'; ctx.strokeRect(20,20, 5*30, 10);

    // Bomb UI
    ctx.save();
    ctx.translate(20, 40);
    for(let i=0;i<this.bombs;i++){
      ctx.fillStyle='rgba(255,180,255,0.85)';
      ctx.beginPath(); ctx.arc(10 + i*18, 0, 6, 0, Math.PI*2); ctx.fill();
      ctx.strokeStyle='rgba(255,255,255,0.6)'; ctx.stroke();
    }
    ctx.restore();

    // Weapon info + power-ups
    ctx.fillStyle='white'; ctx.font='16px sans-serif'; ctx.textAlign='left';
    const tier = this.weaponLevels[this.weapon] ?? 0;
    const levelLabel = tier < 0 ? 'Lv.?': `Lv.${Math.min(tier+1, weaponDefinitions[this.weapon].levels.length)}`;
    ctx.fillText(`${profile.label} ${levelLabel}`, 20, 70);
    if (this.powerUps.length>0){
      ctx.font='14px sans-serif';
      this.powerUps.forEach((p,i)=>{
        const def = powerUpDefinitions[p.type];
        const secs = Math.ceil(p.timer/60);
        ctx.fillStyle='rgba(255,220,180,0.9)';
        ctx.fillText(`${def?.label||'Glyph'} ${secs}s`, 20, 92 + i*16);
      });
    }
  }
}

  class Projectile{
    constructor({x,y,angle,stats}){
      this.x=x; this.y=y;
      this.element = stats.element || 'default';
      this.speed = stats.speed || 9;
      this.damage = stats.damage || 1;
      this.size = stats.size || 6;
      this.life = stats.life || 70;
      this.pierce = stats.pierce || 0;
      this.aoeRadius = stats.aoeRadius || 0;
      this.burnDuration = stats.burnDuration || 0;
      this.burnDps = stats.burnDps || 0;
      this.slowDuration = stats.slowDuration || 0;
      this.chillFactor = stats.chillFactor || 0.5;
      this.splinter = stats.splinter || 0;
      this.color = stats.color || '255,255,150';
      this.trailColor = stats.trailColor || this.color;
      this.bounces = stats.bounces || 0;
      this.elasticity = stats.elasticity ?? 0.85;
      this.bounceOnEnemies = !!stats.bounceOnEnemies;
      this.bounceAllies = !!stats.bounceAllies;
      this.maxSpeed = stats.maxSpeed || this.speed;
      this.vx=Math.cos(angle)*this.speed;
      this.vy=Math.sin(angle)*this.speed;
      this.sourceStats = Object.assign({}, stats);
      this.lastBounce = 0;
    }
    update(dt){
      this.life-=dt;
      this.x+=this.vx*dt;
      this.y+=this.vy*dt;
      if (this.bounces>0){
        const minX = this.size;
        const maxX = window.innerWidth - this.size;
        const minY = this.size;
        const maxY = window.innerHeight - this.size;
        let bounced=false;
        if (this.x <= minX && this.vx < 0){ this.x = minX; this.vx *= -this.elasticity; bounced=true; }
        if (this.x >= maxX && this.vx > 0){ this.x = maxX; this.vx *= -this.elasticity; bounced=true; }
        if (this.y <= minY && this.vy < 0){ this.y = minY; this.vy *= -this.elasticity; bounced=true; }
        if (this.y >= maxY && this.vy > 0){ this.y = maxY; this.vy *= -this.elasticity; bounced=true; }
        if (bounced){
          this.bounces = Math.max(0, this.bounces-1);
          if (this.lastBounce<=0){
            playShootSound('bounce', { volume: 0.25 });
            for (let i=0;i<3;i++){ const p=makeParticle(this.x, this.y, this.trailColor, 2); p.life=12; particles.push(p); }
          }
          this.lastBounce = 6;
        }
      }
      if (this.lastBounce>0) this.lastBounce-=dt;
      const trail = makeParticle(this.x, this.y, this.trailColor, 2);
      trail.vx *= 0.2; trail.vy *= 0.2; trail.life = 20;
      particles.push(trail);
    }
    applyHit(enemy){
      enemy.hp -= this.damage;
      let remove = false;
      const impact = {
        remove: false,
        element: this.element,
        aoeRadius: this.aoeRadius,
        damage: this.damage,
        splinter: this.splinter,
        stats: this.sourceStats
      };
      if (this.element==='fire') enemy.applyBurn(this.burnDuration, this.burnDps);
      if (this.element==='ice') enemy.applyChill(this.slowDuration, this.chillFactor);
      if (this.bounceOnEnemies && this.bounces>0){
        const ex = enemy.x + enemy.width/2;
        const ey = enemy.y + enemy.height/2;
        const bounceAngle = Math.atan2(this.y - ey, this.x - ex) + (Math.random()-0.5)*0.6;
        const speed = Math.max(2, Math.min(this.maxSpeed*1.2, Math.hypot(this.vx, this.vy)*this.elasticity));
        this.vx = Math.cos(bounceAngle) * speed;
        this.vy = Math.sin(bounceAngle) * speed;
        this.bounces = Math.max(0, this.bounces-1);
        this.life -= 4;
        playShootSound('bounce', { volume: 0.35 });
      } else {
        this.pierce = (this.pierce||0) - 1;
        remove = this.pierce < 0;
      }
      impact.remove = remove;
      this.x += this.vx*0.1;
      this.y += this.vy*0.1;
      return impact;
    }
    draw(){
      ctx.save(); ctx.globalCompositeOperation='lighter';
      ctx.fillStyle=`rgba(${this.color},0.15)`; ctx.beginPath(); ctx.arc(this.x,this.y,this.size*2.4,0,Math.PI*2); ctx.fill();
      ctx.fillStyle=`rgba(${this.color},1)`; ctx.beginPath(); ctx.arc(this.x,this.y,this.size,0,Math.PI*2); ctx.fill();
      ctx.restore();
    }
  }

class MirrorClone{
  constructor(type, opts={}){
    this.type = type;
    this.scale = opts.scale || (type==='swarm'?0.68:0.85);
    this.alpha = opts.alpha || 0.55;
    this.offset = opts.offset || 0;
    this.radius = opts.radius || (type==='swarm'?60:90);
    this.tether = opts.tether || (type==='swarm'?0.16:0.12);
    this.lag = opts.lag || (type==='swarm'?12:6);
    this.life = opts.life || 720;
    this.spin = opts.spin || 0;
    this.history = [];
    this.x = player ? player.x : window.innerWidth/2;
    this.y = player ? player.y : window.innerHeight/2;
    this.cooldown = 0;
    this.flip = false;
    const baseHp = player ? player.hp : 4;
    this.maxHp = Math.max(1, Math.floor(baseHp/2));
    this.hp = this.maxHp;
  }
  update(dt){
    if (!player || gameOver){ this.life = 0; return; }
    this.life -= dt;
    this.cooldown = Math.max(0, this.cooldown - dt);
    let targetX = player.x;
    let targetY = player.y;
    let flip = player.flip;
    if (this.lag>0){
      this.history.push({ x: player.x, y: player.y, flip: player.flip });
      if (this.history.length > this.lag){
        const lagged = this.history.shift();
        targetX = lagged.x;
        targetY = lagged.y;
        flip = lagged.flip;
      }
    }
    this.spin += (this.type==='swarm'?0.015:0.006)*dt;
    const ang = this.offset + (this.type==='swarm'?this.spin:0);
    targetX += Math.cos(ang) * this.radius;
    targetY += Math.sin(ang) * this.radius;
    this.x += (targetX - this.x) * this.tether * dt;
    this.y += (targetY - this.y) * this.tether * dt;
    this.y = Math.max((player.height||32)*this.scale*0.5, Math.min(window.innerHeight - (player.height||32)*this.scale*0.5, this.y));
    this.flip = flip;
  }
  takeDamage(amount=1){
    this.hp -= amount;
    if (this.hp<=0) this.life = 0;
  }
  getBounds(){
    const width = (player?.width || 64) * this.scale;
    const height = (player?.height || 32) * this.scale;
    return { x: this.x, y: this.y - height/2, width, height };
  }
  intersects(rectX, rectY, rectW, rectH){
    const b = this.getBounds();
    return b.x < rectX + rectW && b.x + b.width > rectX && b.y < rectY + rectH && b.y + b.height > rectY;
  }
  shoot(profile, angle){
    if (this.life<=0 || this.cooldown>0 || !player) return;
    const cloneStats = Object.assign({}, profile);
    cloneStats.damage = (profile.damage||1) * 0.6;
    cloneStats.speed = (profile.speed||8) * 0.95;
    cloneStats.cooldown = (profile.cooldown||15) * 0.7;
    cloneStats.spread = (profile.spread||0.08) * 0.6;
    cloneStats.shots = Math.max(1, Math.round(profile.shots||1));
    cloneStats.pierce = Math.max(0, Math.round(profile.pierce||0));
    cloneStats.color = profile.color || cloneStats.color;
    if (this.type==='swarm'){
      cloneStats.bounces = Math.max(cloneStats.bounces||0, 2);
      cloneStats.bounceOnEnemies = true;
      cloneStats.bounceAllies = true;
    }
    const originX = this.x + (player.width||64)/2;
    const originY = this.y;
    if (profile.element==='lightning'){
      const lightningProfile = Object.assign({}, cloneStats, {
        damage: (cloneStats.damage||1) * 0.7,
        chain: Math.max(1, (profile.chain||2)-1),
        chainFalloff: profile.chainFalloff || 0.7
      });
      effects.push(new LightningEffect(originX, originY, angle, lightningProfile));
      playShootSound('clone', { volume: 0.36 });
    } else {
      for (let i=0;i<cloneStats.shots;i++){
        const spread = (i-(cloneStats.shots-1)/2) * (cloneStats.spread || 0.04);
        projectiles.push(new Projectile({ x: originX, y: originY, angle: angle+spread, stats: cloneStats }));
      }
      playShootSound('clone', { volume: 0.36 });
    }
    this.cooldown = cloneStats.cooldown;
  }
  draw(){
    if (this.life<=0 || !player) return;
    const width = (player.width||64) * this.scale;
    const height = (player.height||32) * this.scale;
    ctx.save();
    ctx.globalAlpha = this.alpha;
    ctx.translate(this.x, this.y);
    if (this.flip){ ctx.scale(-1,1); ctx.translate(-width,0); }
    ctx.filter = 'hue-rotate(200deg) brightness(0.85)';
    ctx.drawImage(wizardFly, 0, -height/2, width, height);
    ctx.restore();
    if (this.hp < this.maxHp){
      ctx.save();
      ctx.globalAlpha = 0.7;
      ctx.fillStyle = 'rgba(140,190,255,0.5)';
      const barWidth = 38;
      ctx.fillRect(this.x + width/2 - barWidth/2, this.y - height/2 - 8, barWidth*(this.hp/this.maxHp), 3);
      ctx.restore();
    }
  }
}

  class LightningEffect{
    constructor(x,y,angle,profile){
      this.x=x; this.y=y; this.angle=angle; this.life=8; this.hitApplied=false;
      this.profile = Object.assign({}, profile);
      this.targets=findLightningTargets(this.x,this.y,this.angle, (profile.chain||2));
      this.paths=this.targets.map(t=>t?this.buildPath(t.x+t.width/2, t.y+t.height/2):null);
      this.forks=[];
      if (profile.stormForks){
        for(let i=0;i<profile.stormForks;i++){
          const ang = angle + (Math.random()-0.5)*0.8;
          const dist = 140 + Math.random()*120;
          const tx = this.x + Math.cos(ang)*dist;
          const ty = this.y + Math.sin(ang)*dist;
          this.forks.push(this.buildPath(tx, ty, 5, 16));
        }
      }
    }
    buildPath(tx,ty,seg=6,jitter=10){
      const pts=[];
      for (let i=1;i<=seg;i++){
        const p=i/seg;
        const ix=this.x+(tx-this.x)*p + (Math.random()-0.5)*jitter;
        const iy=this.y+(ty-this.y)*p + (Math.random()-0.5)*jitter;
        pts.push({x:ix,y:iy});
      }
      return pts;
    }
    update(dt){
      if (!this.hitApplied){
        const falloff = this.profile.chainFalloff || 0.75;
        this.targets.forEach((t,i)=>{
          if (!t) return;
          const dmg = (this.profile.damage || 2) * Math.pow(falloff, i);
          t.hp -= dmg;
          t.applyShock(this.profile.shockDuration || 30);
          spawnHitParticles(t.x+t.width/2, t.y+t.height/2, 'lightning');
          const idx=enemies.indexOf(t);
          if (t.hp<=0 && idx>=0){
            defeatEnemy(t, idx);
          }
        });
        if (boss){
          if (bossSigils.length>0){
            let shattered=false;
            for (let si=bossSigils.length-1; si>=0; si--){
              const sig=bossSigils[si];
              if (Math.hypot(sig.x - this.x, sig.y - this.y) <= 220){
                const destroyed = sig.takeDamage(Math.round(this.profile.damage || 2));
                if (destroyed){ bossSigils.splice(si,1); shattered = true; }
              }
            }
            if (shattered && bossSigils.length===0){
              boss.shieldActive=false;
              floatTexts.push(new FloatText(window.innerWidth/2 - 110, 100, 'Shield Shattered!', '#ffe6ff'));
            }
          } else {
            const bx=boss.x+boss.width/2, by=boss.y+boss.height/2;
            const dist=Math.hypot(bx-this.x, by-this.y);
            const ang=Math.atan2(by-this.y, bx-this.x);
            const diff=Math.atan2(Math.sin(ang - this.angle), Math.cos(ang - this.angle));
            if (dist<650 && Math.abs(diff)<0.4){
              boss.hp -= (this.profile.damage||2.5)*1.4;
              spawnHitParticles(bx, by, 'lightning');
            }
          }
        }
        sfxHit.currentTime=0; sfxHit.play();
        cameraShake = Math.max(cameraShake, 6);
        this.hitApplied=true;
      }
      this.life-=dt;
    }
    draw(){
      ctx.save(); ctx.globalCompositeOperation='lighter';
      ctx.strokeStyle='rgba(150,210,255,0.9)'; ctx.lineWidth=2.5;
      ctx.beginPath(); ctx.moveTo(this.x,this.y);
      this.paths.forEach(path=>{
        if (!path) return;
        path.forEach(pt=>ctx.lineTo(pt.x, pt.y));
      });
      ctx.stroke();
      if (this.forks.length){
        ctx.strokeStyle='rgba(180,220,255,0.6)'; ctx.lineWidth=1.5;
        this.forks.forEach(path=>{
          ctx.beginPath(); ctx.moveTo(this.x,this.y);
          path.forEach(pt=>ctx.lineTo(pt.x, pt.y));
          ctx.stroke();
        });
      }
      ctx.restore();
    }
  }

  class ArcaneBomb{
    constructor(x,y,profile){
      this.x=x; this.y=y; this.profile=Object.assign({}, profile);
      this.life=50; this.fuse=16; this.radius=24; this.exploded=false;
    }
    explode(){
      if (this.exploded) return;
      this.exploded=true;
      this.life=28;
      spawnShockwave(this.x, this.y);
      spawnHitParticles(this.x, this.y, 'bomb');
      applyAoeDamage(this.x, this.y, 180, (this.profile.damage||2)*1.4, 'bomb');
      damageBossArea(this.x, this.y, (this.profile.damage||2.5)*4.5, 240, 'bomb');
      cameraShake = Math.max(cameraShake, 18);
    }
    update(dt){
      if (!this.exploded){
        this.fuse -= dt;
        this.radius = 24 + (16 - this.fuse)*1.5;
        if (this.fuse<=0) this.explode();
      } else {
        this.radius += 12*dt;
        this.life -= dt;
      }
    }
    draw(){
      ctx.save();
      ctx.globalCompositeOperation='lighter';
      ctx.strokeStyle=this.exploded?'rgba(255,160,255,0.8)':'rgba(200,150,255,0.6)';
      ctx.lineWidth=this.exploded?4:2;
      ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2); ctx.stroke();
      ctx.fillStyle=this.exploded?'rgba(255,150,255,0.25)':'rgba(200,170,255,0.15)';
      ctx.beginPath(); ctx.arc(this.x, this.y, this.radius*0.6, 0, Math.PI*2); ctx.fill();
      ctx.restore();
    }
  }

class SigilMissile{
  constructor(x,y,opts={}){
    this.x=x; this.y=y;
    this.vx=0; this.vy=0;
    this.speed = opts.speed || 3.2;
    this.maxSpeed = opts.maxSpeed || 7.2;
    this.accel = opts.accel || 0.14;
    this.turnRate = opts.turnRate || 0.08;
    this.life = 420;
    this.delay = opts.delay || 0;
    this.element = opts.element || 'bomb';
    this.damage = opts.damage || 2.6;
    this.exploded = false;
    this.radius = 22;
    this.explodeRadius = opts.explodeRadius || 150;
  }
  acquireTarget(){
    let best=null;
    if (boss){
      best = { x: boss.x+boss.width/2, y: boss.y+boss.height/2 };
    }
    let minDist = best ? Math.hypot(best.x - this.x, best.y - this.y) : Infinity;
    for (let i=0;i<enemies.length;i++){
      const e=enemies[i];
      const tx = e.x + e.width/2;
      const ty = e.y + e.height/2;
      const d = Math.hypot(tx-this.x, ty-this.y);
      if (d < minDist){ minDist = d; best = { x: tx, y: ty }; }
    }
    if (!best && player){
      best = { x: player.x + player.width/2 + Math.cos(perfNow()*2)*160, y: player.y + Math.sin(perfNow()*2)*60 };
    }
    return best;
  }
  explode(){
    if (this.exploded) return;
    this.exploded = true;
    this.life = 40;
    spawnShockwave(this.x, this.y);
    spawnHitParticles(this.x, this.y, 'bomb');
    applyAoeDamage(this.x, this.y, this.explodeRadius, this.damage*1.1, this.element);
    damageBossArea(this.x, this.y, this.damage*2.1, this.explodeRadius+10, this.element);
    cameraShake = Math.max(cameraShake, 12);
    playShootSound('missile', { volume: 0.62 });
  }
  update(dt){
    if (this.exploded){
      this.radius += 10*dt;
      this.life -= dt;
      return;
    }
    if (this.delay>0){ this.delay -= dt; return; }
    this.life -= dt;
    const target = this.acquireTarget();
    if (target){
      const desired = Math.atan2(target.y - this.y, target.x - this.x);
      if (this.vx===0 && this.vy===0){
        this.vx = Math.cos(desired)*this.speed;
        this.vy = Math.sin(desired)*this.speed;
      } else {
        const current = Math.atan2(this.vy, this.vx);
        const diff = Math.atan2(Math.sin(desired-current), Math.cos(desired-current));
        const newAng = current + diff * this.turnRate * dt * 60;
        const spd = Math.min(this.maxSpeed, Math.hypot(this.vx, this.vy) + this.accel*dt);
        this.vx = Math.cos(newAng) * spd;
        this.vy = Math.sin(newAng) * spd;
      }
    }
    this.x += this.vx*dt;
    this.y += this.vy*dt;
    const spark = makeParticle(this.x, this.y, '200,150,255', 3);
    spark.life = 18; spark.vx *= 0.1; spark.vy *= 0.1;
    particles.push(spark);
    if (this.life<=0){ this.explode(); return; }
    for (let i=enemies.length-1;i>=0;i--){
      const e=enemies[i];
      if (this.x > e.x-10 && this.x < e.x+e.width+10 && this.y > e.y-10 && this.y < e.y+e.height+10){
        this.explode();
        break;
      }
    }
    if (!this.exploded && boss && this.x > boss.x && this.x < boss.x+boss.width && this.y > boss.y && this.y < boss.y+boss.height){
      this.explode();
    }
    if (!this.exploded && (this.x<-60 || this.x>window.innerWidth+60 || this.y<-60 || this.y>window.innerHeight+60)){
      this.explode();
    }
  }
  draw(){
    ctx.save();
    ctx.globalCompositeOperation='lighter';
    if (!this.exploded){
      ctx.fillStyle='rgba(180,150,255,0.8)';
      ctx.beginPath(); ctx.arc(this.x, this.y, 10, 0, Math.PI*2); ctx.fill();
      ctx.strokeStyle='rgba(255,200,255,0.6)';
      ctx.lineWidth=2;
      ctx.beginPath(); ctx.arc(this.x, this.y, 18 + Math.sin(perfNow()*8)*2, 0, Math.PI*2); ctx.stroke();
    } else {
      ctx.strokeStyle='rgba(255,210,255,0.4)';
      ctx.lineWidth=3;
      ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2); ctx.stroke();
    }
    ctx.restore();
  }
}

class BossProjectile{
  constructor(x,y,tx,ty,opts={}){
    this.x=x; this.y=y;
    const speed = opts.speed || 4;
    const ang=Math.atan2(ty-y, tx-x);
    this.vx=Math.cos(ang)*speed; this.vy=Math.sin(ang)*speed;
    this.size=opts.size || 8;
    this.color=opts.color || 'rgba(255,50,50,1)';
    this.seek=opts.seek || 0;
    this.wobble=opts.wobble || 0;
    this.time=0;
    this.hp = opts.hp || Math.max(1, Math.ceil(this.size*0.3) + (opts.seek?1:0));
    this.maxHp = this.hp;
    this.element = opts.element || 'default';
    this.flash = 0;
  }

  update(dt){
    this.time += dt;
    if (this.seek && player){
      const ang = Math.atan2(player.y - this.y, player.x - this.x);
      this.vx += Math.cos(ang) * this.seek * 0.002 * dt;
      this.vy += Math.sin(ang) * this.seek * 0.002 * dt;
    }
    if (this.wobble){
      const mag = Math.hypot(this.vx,this.vy);
      const wob = Math.sin(this.time * 0.1 * this.wobble) * 0.2;
      const ang = Math.atan2(this.vy,this.vx) + wob * dt;
      this.vx = Math.cos(ang) * mag;
      this.vy = Math.sin(ang) * mag;
    }
    this.x+=this.vx*dt; this.y+=this.vy*dt;
    if (this.flash>0) this.flash-=dt;
  }

  takeDamage(dmg){
    this.hp -= dmg;
    this.flash = 6;
    return this.hp <= 0;
  }

  draw(){
    ctx.save();
    ctx.fillStyle=this.color;
    ctx.beginPath(); ctx.arc(this.x,this.y,this.size,0,Math.PI*2); ctx.fill();
    if (this.flash>0){
      ctx.strokeStyle='rgba(255,255,255,0.8)';
      ctx.lineWidth=2;
      ctx.beginPath(); ctx.arc(this.x,this.y,this.size+2,0,Math.PI*2); ctx.stroke();
    }
    ctx.restore();
  }
}

class BossSigil{
  constructor(boss,angle){
    this.boss=boss;
    this.angle=angle;
    this.radius=Math.max(boss.width,boss.height)*0.55 + 70;
    this.size=52;
    this.hp=10;
    this.spin=0.01 + Math.random()*0.02;
    this.flash=0;
  }
  update(dt){
    if (!this.boss) return;
    this.angle += this.spin*dt;
    const cx=this.boss.x+this.boss.width/2;
    const cy=this.boss.y+this.boss.height/2;
    this.x = cx + Math.cos(this.angle)*this.radius;
    this.y = cy + Math.sin(this.angle)*this.radius;
    if (this.flash>0) this.flash-=dt;
  }
  takeDamage(dmg){
    this.hp -= dmg;
    this.flash=12;
    spawnHitParticles(this.x,this.y,'lightning');
    if (this.hp<=0){
      spawnExplosion(this.x,this.y);
      return true;
    }
    return false;
  }
  draw(){
    if (!this.x && !this.y) return;
    ctx.save();
    ctx.translate(this.x,this.y);
    const pulse = 1 + Math.sin(perfNow()*3 + this.angle)*0.15;
    ctx.scale(pulse,pulse);
    if (this.flash>0){
      ctx.globalAlpha = Math.max(0.2, Math.min(1, this.flash/12));
    } else {
      ctx.globalAlpha = 0.8;
    }
    ctx.globalCompositeOperation='lighter';
    ctx.fillStyle='rgba(120,200,255,0.5)';
    ctx.beginPath(); ctx.arc(0,0,this.size/2,0,Math.PI*2); ctx.fill();
    ctx.globalCompositeOperation='source-over';
    ctx.globalAlpha=1;
    ctx.strokeStyle='rgba(255,255,255,0.85)';
    ctx.lineWidth=3;
    ctx.beginPath(); ctx.arc(0,0,this.size/2+6,0,Math.PI*2); ctx.stroke();
    ctx.restore();
  }
}

class BossLaser{
  constructor(orientation,pos){
    this.orientation=orientation;
    this.pos=pos;
    this.warning=90;
    this.duration=70;
    this.timer=0;
    this.active=false;
    this.done=false;
    this.width=orientation==='horizontal'?120:120;
  }
  update(dt){
    this.timer += dt;
    if (!this.active){
      if (this.timer >= this.warning){
        this.active=true;
        this.timer=0;
        cameraShake = Math.max(cameraShake, 8);
      }
    } else if (this.timer >= this.duration){
      this.done=true;
    }
  }
  hitPlayer(p){
    if (!this.active) return false;
    const half=this.width/2;
    if (this.orientation==='horizontal'){
      return p.y < this.pos + half && p.y + p.height > this.pos - half;
    }
    return p.x < this.pos + half && p.x + p.width > this.pos - half;
  }
  draw(){
    const half=this.width/2;
    const w=window.innerWidth, h=window.innerHeight;
    ctx.save();
    if (!this.active){
      ctx.fillStyle='rgba(120,200,255,0.18)';
      ctx.strokeStyle='rgba(255,255,255,0.4)';
      ctx.setLineDash([12,12]);
      ctx.lineWidth=2;
    } else {
      ctx.globalCompositeOperation='lighter';
      ctx.fillStyle='rgba(255,90,160,0.55)';
      ctx.shadowColor='rgba(255,120,220,0.9)';
      ctx.shadowBlur=30;
    }
    if (this.orientation==='horizontal'){
      ctx.fillRect(0, this.pos - half, w, this.width);
      if (!this.active) ctx.strokeRect(0, this.pos - half, w, this.width);
    } else {
      ctx.fillRect(this.pos - half, 0, this.width, h);
      if (!this.active) ctx.strokeRect(this.pos - half, 0, this.width, h);
    }
    ctx.restore();
  }
}

class Boss{
  constructor(type){
    this.type=type;
    this.sprite=enemiesSprites[type];
    this.width=384; this.height=384;
    this.x=window.innerWidth; this.y=window.innerHeight/2 - this.height/2;
    this.hp=200 + type*50; this.maxHp=this.hp;
    this.timer=0; this.anim=0; this.spiral=0;
    this.targetX = window.innerWidth - this.width - 80;
    this.targetY = this.y;
    this.moveTimer = 160;
    this.phase=1;
    this.phase2Triggered=false;
    this.phase3Triggered=false;
    this.shieldPulse=0;
    this.shieldActive=false;
    this.laserTimer=240;
  }
  update(dt){
    this.timer+=dt; this.anim+=dt;
    this.moveTimer -= dt;
    if (this.moveTimer<=0){
      this.moveTimer = 140 - this.phase*10 + Math.random()*120;
      const minX = window.innerWidth*0.45;
      const maxX = window.innerWidth - this.width - 60;
      this.targetX = Math.min(maxX, Math.max(minX, this.targetX + (Math.random()*240 - 120)));
      const minY = 40;
      const maxY = window.innerHeight - this.height - 40;
      this.targetY = Math.min(maxY, Math.max(minY, this.targetY + (Math.random()*260 - 130)));
    }

    let desiredX = this.targetX;
    let desiredY = this.targetY;
    if(this.type===0){
      const wobble = 60 + this.phase*18;
      desiredY += Math.sin(this.anim*(0.03 + this.phase*0.005)*60)*wobble;
      desiredX += Math.cos(this.anim*0.012*60)*(24 + this.phase*8);
    } else if(this.type===1){
      const sway = 80 + this.phase*22;
      desiredY += Math.sin(this.anim*(0.02 + this.phase*0.003)*60)*sway;
      desiredX += Math.sin(this.anim*0.01*60)*(34 + this.phase*12);
    } else if(this.type===2){
      const drift = 70 + this.phase*24;
      desiredY += Math.sin(this.anim*(0.04 + this.phase*0.008)*60)*drift;
      desiredX += Math.cos(this.anim*(0.025 + this.phase*0.006)*60)*(40 + this.phase*15);
      this.spiral += (0.2 + this.phase*0.05)*dt;
    }

    const minXBound = window.innerWidth*0.35;
    const maxXBound = window.innerWidth - this.width - 40;
    const minYBound = 20;
    const maxYBound = window.innerHeight - this.height - 20;
    desiredX = Math.max(minXBound, Math.min(maxXBound, desiredX));
    desiredY = Math.max(minYBound, Math.min(maxYBound, desiredY));

    this.x += (desiredX - this.x)*0.02*dt;
    this.y += (desiredY - this.y)*0.02*dt;
    this.y = Math.max(0, Math.min(window.innerHeight - this.height, this.y));

    const cx=this.x+this.width/2, cy=this.y+this.height/2;
    this.shieldPulse = this.shieldActive ? Math.min(1, this.shieldPulse + 0.04*dt) : Math.max(0, this.shieldPulse - 0.05*dt);

    if (!this.phase2Triggered && this.hp <= this.maxHp*0.7){
      this.phase = 2;
      this.phase2Triggered = true;
      summonBossSigils(this);
      floatTexts.push(new FloatText(window.innerWidth/2 - 90, 80, 'Arcane Ward!', '#7fd9ff'));
      cameraShake = Math.max(cameraShake, 8);
      bgHueTimer = Math.max(bgHueTimer, 240);
    }

    if (!this.phase3Triggered && this.hp <= this.maxHp*0.4){
      this.phase = 3;
      this.phase3Triggered = true;
      this.laserTimer = 90;
      floatTexts.push(new FloatText(window.innerWidth/2 - 110, 120, 'Tempest Fury!', '#ff96d8'));
      cameraShake = Math.max(cameraShake, 14);
      spawnShockwave(cx, cy);
      summonBossSigils(this);
      setTempestWeather();
    }

    if(this.type===0){
      const cooldown = this.phase===1?60:(this.phase===2?45:30);
      if(this.timer>=cooldown){
        const base=Math.atan2(player.y-cy, player.x-cx);
        for(let i=-2;i<=2;i++){
          const ang=base+i*0.2;
          const tx=cx+Math.cos(ang)*1000;
          const ty=cy+Math.sin(ang)*1000;
          const opts = { speed: 4 + this.phase*0.8, color: i===0?'rgba(255,180,120,1)':'rgba(255,80,80,1)' };
          if (this.phase>=3 && i===0) opts.seek = 5;
          bossProjectiles.push(new BossProjectile(cx,cy,tx,ty,opts));
        }
        if (this.phase>=2){
          const ang = base + (Math.random()-0.5)*0.6;
          const tx=cx+Math.cos(ang)*1000;
          const ty=cy+Math.sin(ang)*1000;
          bossProjectiles.push(new BossProjectile(cx,cy,tx,ty,{speed:6,color:'rgba(180,220,255,0.95)',seek:this.phase===3?6:0}));
        }
        this.timer=0;
      }
    } else if(this.type===1){
      const cooldown = this.phase===1?150:(this.phase===2?120:90);
      if(this.timer>=cooldown){
        const burst = this.phase>=3?14:10;
        for(let i=0;i<burst;i++){
          const ang=(i/burst)*Math.PI*2;
          const tx=cx+Math.cos(ang)*1000;
          const ty=cy+Math.sin(ang)*1000;
          const opts = { speed: 3.5 + this.phase*0.6, color:'rgba(255,160,90,0.95)' };
          bossProjectiles.push(new BossProjectile(cx,cy,tx,ty,opts));
        }
        if (this.phase>=2) spawnBossMinions(this, this.phase===3?3:2);
        if (this.phase===3){
          bossProjectiles.push(new BossProjectile(cx,cy,player.x,player.y,{speed:5.5,color:'rgba(255,220,120,0.9)',seek:4}));
        }
        this.timer=0;
      }
    } else if(this.type===2){
      const cooldown = this.phase===1?15:(this.phase===2?10:6);
      if(this.timer>=cooldown){
        const ang=this.spiral;
        const tx=cx+Math.cos(ang)*1000;
        const ty=cy+Math.sin(ang)*1000;
        const opts = { speed: 4 + this.phase*0.9, color:'rgba(180,130,255,0.95)', wobble:this.phase>=2?1.5:0 };
        bossProjectiles.push(new BossProjectile(cx,cy,tx,ty,opts));
        if (this.phase>=3){
          const ang2 = this.spiral + Math.PI;
          const tx2=cx+Math.cos(ang2)*1000;
          const ty2=cy+Math.sin(ang2)*1000;
          bossProjectiles.push(new BossProjectile(cx,cy,tx2,ty2,{speed:4.5,color:'rgba(120,200,255,0.9)',wobble:2.5}));
        }
        this.timer=0;
      }
    }

    if (this.phase>=3){
      this.laserTimer -= dt;
      if (this.laserTimer<=0){
        spawnBossLaser(Math.random()<0.5?'horizontal':'vertical');
        if (Math.random()<0.35) spawnBossLaser(Math.random()<0.5?'horizontal':'vertical');
        this.laserTimer = 220 - this.phase*40 + Math.random()*80;
      }
    }
  }
  draw(){
    ctx.drawImage(this.sprite, this.x, this.y, this.width, this.height);
    ctx.save();
    const barW=this.width, barH=10;
    ctx.fillStyle='rgba(0,0,0,0.5)';
    ctx.fillRect(this.x, this.y-barH-4, barW, barH);
    ctx.fillStyle='red';
    ctx.fillRect(this.x, this.y-barH-4, barW*(this.hp/this.maxHp), barH);
    ctx.strokeStyle='white'; ctx.strokeRect(this.x, this.y-barH-4, barW, barH);
    ctx.fillStyle='white'; ctx.font='16px sans-serif'; ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.fillText(this.hp, this.x+barW/2, this.y-barH-9);
    ctx.restore();
    if (this.shieldPulse>0){
      const cx=this.x+this.width/2, cy=this.y+this.height/2;
      const rad=Math.max(this.width,this.height)*0.6 + Math.sin(perfNow()*5)*6*this.shieldPulse;
      ctx.save();
      ctx.globalCompositeOperation='lighter';
      ctx.lineWidth=8*this.shieldPulse;
      ctx.strokeStyle=`rgba(120,200,255,${0.5*this.shieldPulse})`;
      ctx.beginPath(); ctx.arc(cx,cy,rad,0,Math.PI*2); ctx.stroke();
      ctx.restore();
    }
  }
}

class Enemy{
  constructor(){
    this.sprite = enemiesSprites[Math.floor(Math.random()*enemiesSprites.length)];
    this.width=96; this.height=96;

    // Spawn and baseline
    this.x = window.innerWidth + 50;
    this.y = Math.random()*(window.innerHeight - this.height);
    this.baseY = this.y;
    this.drift = (Math.random()*0.5 + 0.2) * (Math.random()<0.5 ? -1 : 1);

    // Movement/HP
    this.baseSpeed = 2 + Math.random()*1.5; // constant world speed
    this.hp = 3;

    // Zig-zag variety
    this.waveOffset = Math.random()*Math.PI*2;
    this.waveSpeed  = 0.005 + Math.random()*0.02;
    this.waveAmp    = 10 + Math.random()*110; // 10120px amplitude

    this.slowTimer=0;
    this.chillFactor=1;
    this.burnTimer=0;
    this.burnDps=0;
    this.shockTimer=0;
    this.statusPulse=0;
  }
  update(dt){
    let speedMult = 1;
    if (this.slowTimer>0){
      this.slowTimer-=dt;
      speedMult *= this.chillFactor || 0.5;
      if (this.slowTimer<=0) this.chillFactor=1;
    }
    if (this.shockTimer>0){
      this.shockTimer-=dt;
      speedMult *= 0.35;
      if (Math.random()<0.12*dt) particles.push(makeParticle(this.x+this.width/2, this.y+this.height/2, '120,200,255', 3));
    }
    const spd = this.baseSpeed * speedMult;
    this.x -= spd*dt;

    // drift baseline up/down
    this.baseY += this.drift*dt;
    if (this.baseY < 0 || this.baseY > window.innerHeight - this.height) this.drift *= -1;

    // layered wobble around drifting baseline
    const t = perfNow();
    const wobble = Math.sin(t * this.waveSpeed + this.waveOffset) * this.waveAmp;
    const wobble2 = Math.sin(t * this.waveSpeed * 1.7 + this.waveOffset * 1.5) * this.waveAmp * 0.25;
    this.y = this.baseY + wobble + wobble2;

    // Stay in vertical bounds
    this.y = Math.max(0, Math.min(window.innerHeight - this.height, this.y));

    if (this.burnTimer>0){
      this.burnTimer-=dt;
      this.hp -= this.burnDps * dt;
      this.statusPulse = Math.min(1, this.statusPulse + 0.05*dt);
      if (Math.random()<0.18*dt) particles.push(makeParticle(this.x+this.width/2, this.y+this.height/2, '255,120,0', 4));
      if (this.burnTimer<=0) this.burnDps=0;
    } else {
      this.statusPulse = Math.max(0, this.statusPulse - 0.05*dt);
    }
  }
  draw(){
    ctx.drawImage(this.sprite, this.x, this.y, this.width, this.height);
    if (this.statusPulse>0){
      ctx.save();
      ctx.globalAlpha = Math.min(0.5, this.statusPulse*0.5);
      ctx.fillStyle='rgba(255,120,40,1)';
      if (this.shockTimer>0) ctx.fillStyle='rgba(120,220,255,0.8)';
      else if (this.slowTimer>0) ctx.fillStyle='rgba(180,220,255,0.6)';
      ctx.fillRect(this.x, this.y, this.width, this.height);
      ctx.restore();
    }
  }
  applyBurn(duration, dps){
    this.burnTimer = Math.max(this.burnTimer, duration||0);
    this.burnDps = Math.max(this.burnDps, dps||0);
  }
  applyChill(duration, factor){
    this.slowTimer = Math.max(this.slowTimer, duration||0);
    this.chillFactor = Math.min(this.chillFactor, factor||0.5);
    this.statusPulse = Math.max(this.statusPulse, 0.4);
  }
  applyShock(duration){
    this.shockTimer = Math.max(this.shockTimer, duration||0);
    this.statusPulse = Math.max(this.statusPulse, 0.6);
  }
}

  class Collectable{
    constructor(x,y,type){
      this.x=x; this.y=y; this.type=type; this.size=24; this.floatOffset=Math.random()*Math.PI*2;
      this.visual = collectableVisuals[type] || { sprite: orbSprite, hue: 0 };
      this.spin = (Math.random()*0.02 + 0.01) * (Math.random()<0.5?-1:1);
      this.rotation = Math.random()*Math.PI*2;
    }
    update(dt){
      this.x -= 2*dt;
      this.floatOffset += 0.05*dt;
      this.rotation += this.spin*dt;
    }
    draw(){
      const dy = Math.sin(this.floatOffset)*4;
      const sprite = this.visual.sprite || orbSprite;
      const hue = this.visual.hue;
      const glow = this.visual.glow;
      const px = this.x + this.size/2;
      const py = this.y + dy + this.size/2;
      ctx.save();
      ctx.translate(px, py);
      if (hue !== undefined) ctx.filter = `hue-rotate(${hue}deg)`;
      if (sprite!==heartSprite) ctx.rotate(this.rotation);
      ctx.drawImage(sprite, -this.size/2, -this.size/2, this.size, this.size);
      ctx.restore();
      if (glow){
        ctx.save();
        ctx.globalCompositeOperation='lighter';
        ctx.fillStyle=glow;
        ctx.beginPath(); ctx.arc(px, py, this.size*0.6, 0, Math.PI*2); ctx.fill();
        ctx.restore();
      }
    }
  }

class FloatText{
  constructor(x,y,text,color){ this.x=x; this.y=y; this.text=text; this.color=color; this.life=40; }
  update(dt){ this.y -= 0.5*dt; this.life-=dt; }
  draw(){ ctx.fillStyle=this.color; ctx.font='16px sans-serif'; ctx.fillText(this.text,this.x,this.y); }
}

/* ========= Particles ========= */
function spawnExplosion(x,y){
  for(let i=0;i<28;i++) particles.push(makeParticle(x,y,(Math.random()<0.6)?'255,120,0':'255,60,0',5));
}
function spawnBlood(x,y){
  for(let i=0;i<120;i++) particles.push(makeParticle(x,y,'150,0,0',6));
}
function spawnHitParticles(x,y,type='default'){
  let color='200,160,255', size=4;
  if (type==='fire'){ color='255,120,0'; size=5; }
  if (type==='ice'){ color='160,220,255'; size=3; }
  if (type==='lightning'){ color='120,200,255'; size=3; }
  if (type==='bomb'){ color='255,150,255'; size=6; }
  for(let i=0;i<32;i++) particles.push(makeParticle(x,y,color,size));
}
function spawnShockwave(x,y){
  const ring=48;
  for(let i=0;i<ring;i++){
    const ang=(i/ring)*Math.PI*2;
    const speed=4 + Math.random()*2;
    const p=makeParticle(x,y,'220,220,255',4);
    p.vx = Math.cos(ang)*speed;
    p.vy = Math.sin(ang)*speed;
    p.life = 18 + Math.random()*18;
    particles.push(p);
  }
}
function resolveBouncyProjectiles(){
  for (let i=0;i<projectiles.length;i++){
    const a = projectiles[i];
    if (!a || !a.bounceAllies) continue;
    for (let j=i+1;j<projectiles.length;j++){
      const b = projectiles[j];
      if (!b || !b.bounceAllies) continue;
      const dx = a.x - b.x;
      const dy = a.y - b.y;
      const minDist = (a.size || 6) + (b.size || 6);
      const distSq = dx*dx + dy*dy;
      if (distSq === 0 || distSq > minDist*minDist) continue;
      const dist = Math.sqrt(distSq);
      const tmpVx = a.vx, tmpVy = a.vy;
      a.vx = b.vx; a.vy = b.vy;
      b.vx = tmpVx; b.vy = tmpVy;
      a.bounces = Math.max(0, a.bounces-1);
      b.bounces = Math.max(0, b.bounces-1);
      const adjust = (minDist - dist) / 2;
      if (adjust>0){
        const nx = dx / (dist || 1);
        const ny = dy / (dist || 1);
        a.x += nx * adjust;
        a.y += ny * adjust;
        b.x -= nx * adjust;
        b.y -= ny * adjust;
      }
      playShootSound('bounce', { volume: 0.2 });
    }
  }
}
function makeParticle(x,y,color,size){
  return { x,y, vx:(Math.random()-0.5)*6, vy:(Math.random()-0.5)*6, life:24+Math.random()*12, size, color };
}
function drawParticles(dt){
  ctx.save(); ctx.globalCompositeOperation='lighter';
  for (let i=particles.length-1;i>=0;i--){
    const p=particles[i]; p.x+=p.vx*dt; p.y+=p.vy*dt; p.life-=dt;
    const a=Math.max(0,p.life/36);
    ctx.fillStyle=`rgba(${p.color},${a})`;
    ctx.beginPath(); ctx.arc(p.x,p.y,p.size,0,Math.PI*2); ctx.fill();
    if (p.life<=0) particles.splice(i,1);
  }
  ctx.restore();
}

function updateWeather(dt){
  if((weatherTimer-=dt)<=0) setWeather();
  const w=window.innerWidth, h=window.innerHeight;
  if(weather==='rain'){
    for(let i=0;i<5*dt;i++) weatherParticles.push({x:Math.random()*w, y:-10, vx:-2+Math.random(), vy:10+Math.random()*4, type:'rain', life:h});
  } else if(weather==='snow'){
    for(let i=0;i<2*dt;i++) weatherParticles.push({x:Math.random()*w, y:-10, vx:-1+Math.random()*2, vy:2+Math.random()*1, type:'snow', life:h});
  } else if(weather==='sand'){
    for(let i=0;i<4*dt;i++) weatherParticles.push({x:Math.random()*w, y:Math.random()*h, vx:-3-Math.random()*2, vy:Math.random()-0.5, type:'sand', life:200});
  } else if(weather==='wind'){
    for(let i=0;i<dt;i++) if(Math.random()<0.3) weatherParticles.push({x:Math.random()*w, y:Math.random()*h, vx:-2-Math.random()*2, vy:Math.random()-0.5, type:'leaf', rot:Math.random()*Math.PI, life:200});
  } else if(weather==='tempest'){
    for(let i=0;i<3*dt;i++) weatherParticles.push({x:Math.random()*w, y:-20, vx:(Math.random()-0.5)*3, vy:14+Math.random()*4, type:'tempest', life:h});
    if(Math.random()<0.004*dt){
      const x=Math.random()*w;
      weatherParticles.push({x, y:-40, vx:0, vy:18, type:'bolt', life:h});
    }
  }
  if((weather==='rain' || weather==='sand' || weather==='tempest') && Math.random()<0.002*dt) lightningFlash=5;
  for(let i=weatherParticles.length-1;i>=0;i--){
    const p=weatherParticles[i]; p.x+=p.vx*dt; p.y+=p.vy*dt; p.life-=dt;
    if(p.type==='rain') p.vy+=0.1*dt;
    if(p.type==='bolt') p.vy+=0.4*dt;
    if(p.life<=0 || p.y>h+20 || p.x<-20 || p.x>w+20) weatherParticles.splice(i,1);
  }
  lightningFlash = Math.max(0, lightningFlash - dt);
}

function drawWeather(){
  ctx.save();
  weatherParticles.forEach(p=>{
    if(p.type==='rain'){
      ctx.strokeStyle='rgba(160,160,255,0.6)';
      ctx.beginPath(); ctx.moveTo(p.x,p.y); ctx.lineTo(p.x+p.vx*2,p.y+p.vy*2); ctx.stroke();
    } else if(p.type==='snow'){
      ctx.fillStyle='rgba(255,255,255,0.8)';
      ctx.beginPath(); ctx.arc(p.x,p.y,2,0,Math.PI*2); ctx.fill();
    } else if(p.type==='sand'){
      ctx.fillStyle='rgba(194,178,128,0.7)';
      ctx.fillRect(p.x,p.y,2,2);
    } else if(p.type==='leaf'){
      ctx.fillStyle='rgba(200,150,50,0.8)';
      ctx.save(); ctx.translate(p.x,p.y); ctx.rotate(p.rot||0); ctx.fillRect(-3,-1,6,2); ctx.restore();
      p.rot += 0.05*frameDt;
    } else if(p.type==='tempest'){
      ctx.strokeStyle='rgba(180,150,255,0.5)';
      ctx.lineWidth=2;
      ctx.beginPath(); ctx.moveTo(p.x,p.y); ctx.lineTo(p.x+p.vx*2, p.y+p.vy*2); ctx.stroke();
    } else if(p.type==='bolt'){
      ctx.strokeStyle='rgba(255,220,255,0.85)';
      ctx.lineWidth=3;
      ctx.beginPath();
      ctx.moveTo(p.x, p.y);
      ctx.lineTo(p.x + (Math.random()-0.5)*30, p.y + 50);
      ctx.stroke();
    }
  });
  ctx.restore();
  if(lightningFlash>0){ ctx.fillStyle=`rgba(255,255,255,${lightningFlash/10})`; ctx.fillRect(0,0,window.innerWidth,window.innerHeight); }
}

/* ========= Helpers ========= */
function perfNow(){ return (performance || Date).now ? (performance.now()/1000) : (Date.now()/1000); }
function findLightningTargets(px,py,angle,count=2){
  const cos=Math.cos(angle), sin=Math.sin(angle);
  const maxDist=600;
  return enemies
    .map(e=>{
      const ex=e.x+e.width/2, ey=e.y+e.height/2;
      const dx=ex-px, dy=ey-py;
      const dist=Math.hypot(dx,dy);
      const dir = dist>0 ? (dx*cos + dy*sin)/dist : 0;
      return { e, dist, dir };
    })
    .filter(o=>o.dist<maxDist && o.dir>-0.2)
    .sort((a,b)=>a.dist-b.dist)
    .slice(0,count)
    .map(o=>o.e);
}
function dropCollectable(x,y){
  const roll=Math.random();
  if (roll<0.18) collectables.push(new Collectable(x,y,'heart'));
  else if (roll<0.55){
    const types=['fire','lightning','ice'];
    collectables.push(new Collectable(x,y, types[Math.floor(Math.random()*types.length)]));
  } else if (roll<0.82){
    const boosts=['rapid','fury','focus'];
    collectables.push(new Collectable(x,y, boosts[Math.floor(Math.random()*boosts.length)]));
  } else if (roll<0.94){
    collectables.push(new Collectable(x,y,'bomb'));
  } else if (roll<0.97){
    collectables.push(new Collectable(x,y,'mirror'));
  } else {
    collectables.push(new Collectable(x,y,'shadows'));
  }
}

function defeatEnemy(enemy, index){
  if (!enemy) return;
  const cx=enemy.x+enemy.width/2;
  const cy=enemy.y+enemy.height/2;
  spawnExplosion(cx, cy);
  dropCollectable(enemy.x, enemy.y);
  enemies.splice(index,1);
  killCount++;
  if(killCount>=20 && !boss) spawnBoss();
  cameraShake = Math.max(cameraShake, 10);
}

function applyAoeDamage(x,y,radius,damage,element='default',ignore){
  if (radius<=0 || damage<=0) return;
  const toRemove=[];
  for (let i=enemies.length-1;i>=0;i--){
    const enemy=enemies[i];
    if (!enemy || enemy===ignore) continue;
    const ex=enemy.x+enemy.width/2;
    const ey=enemy.y+enemy.height/2;
    if (Math.hypot(ex-x, ey-y) <= radius){
      enemy.hp -= damage;
      if (element==='fire') enemy.applyBurn(90, 0.04);
      if (element==='ice') enemy.applyChill(90, 0.5);
      spawnHitParticles(ex, ey, element);
      if (enemy.hp<=0) toRemove.push(i);
    }
  }
  toRemove.sort((a,b)=>b-a).forEach(idx=> defeatEnemy(enemies[idx], idx));
}

function damageBossArea(x,y,damage,radius,element='default'){
  if (!boss) return;
  if (bossSigils.length>0){
    let shattered=false;
    for (let si=bossSigils.length-1; si>=0; si--){
      const sig=bossSigils[si];
      if (Math.hypot(sig.x - x, sig.y - y) <= radius){
        const destroyed = sig.takeDamage(Math.round(damage));
        if (destroyed){ bossSigils.splice(si,1); shattered=true; }
      }
    }
    if (shattered){
      if (bossSigils.length===0){
        boss.shieldActive=false;
        floatTexts.push(new FloatText(window.innerWidth/2 - 110, 100, 'Shield Shattered!', '#ffe6ff'));
        cameraShake = Math.max(cameraShake, 12);
      }
    }
  } else {
    const bx=boss.x+boss.width/2, by=boss.y+boss.height/2;
    if (Math.hypot(bx-x, by-y) <= radius + Math.max(boss.width,boss.height)*0.3){
      boss.hp -= damage;
      spawnHitParticles(bx, by, element);
    }
  }
}

function spawnSplinters(x,y,count,stats){
  if (!count || !stats) return;
  const baseAngle = Math.random()*Math.PI*2;
  for(let i=0;i<count;i++){
    const ang = baseAngle + (i/count)*Math.PI*2;
    const shardStats = Object.assign({}, stats, {
      speed: (stats.speed||8)*0.9,
      damage: Math.max(0.4, (stats.damage||1)*0.65),
      size: Math.max(4, (stats.size||6)*0.6),
      life: 40,
      pierce: 0,
      aoeRadius: 0,
      splinter: 0
    });
    projectiles.push(new Projectile({ x, y, angle: ang, stats: shardStats }));
  }
}

function spawnBouncingOrbs(x,y,count,stats){
  if (!count || !stats) return;
  const color = stats.color || '255,200,255';
  for (let i=0;i<count;i++){
    const ang = Math.random()*Math.PI*2;
    const orbStats = Object.assign({}, stats, {
      damage: Math.max(0.8, (stats.damage||1)*0.9),
      speed: 6 + Math.random()*1.5,
      life: Math.max(160, (stats.life||70)+60),
      pierce: Math.max(1, (stats.pierce||0)),
      size: Math.max(6, (stats.size||6)+2),
      color,
      trailColor: color,
      bounces: Math.max(3, (stats.bounces||0) + 3),
      elasticity: 0.9,
      bounceOnEnemies: true,
      bounceAllies: true
    });
    projectiles.push(new Projectile({ x, y, angle: ang, stats: orbStats }));
  }
  playShootSound('bounce', { volume: 0.55 });
}

function summonBossSigils(boss){
  bossSigils = [];
  const count = boss.phase>=3 ? 4 : 3;
  for(let i=0;i<count;i++) bossSigils.push(new BossSigil(boss, (Math.PI*2*i)/count));
  boss.shieldActive = true;
  cameraShake = Math.max(cameraShake, 6);
}

function spawnBossLaser(orientation,pos){
  const w=window.innerWidth, h=window.innerHeight;
  const placement = typeof pos==='number' ? pos : (orientation==='horizontal' ? (h*0.2 + Math.random()*h*0.6) : (w*0.2 + Math.random()*w*0.6));
  bossHazards.push(new BossLaser(orientation, placement));
}

function spawnBossMinions(boss,count){
  for(let i=0;i<count;i++){
    const minion=new Enemy();
    minion.x = boss.x - 80 - Math.random()*120;
    minion.y = boss.y + boss.height/2 + (Math.random()*160 - 80);
    minion.baseY = minion.y;
    minion.hp = 2 + Math.floor(Math.random()*2);
    minion.baseSpeed = 3 + Math.random()*1.5;
    enemies.push(minion);
  }
}

function spawnBoss(){
  boss = new Boss(Math.floor(Math.random()*enemiesSprites.length));
  weather = 'rain';
  weatherTimer = 1200;
  weatherParticles = [];
  lightningFlash = 8;
  killCount = 0;
  bossSigils = [];
  bossHazards = [];
  bossDropTimer = 240;
}

function spawnBossDrop(){
  if (!boss) return;
  const roll = Math.random();
  let type;
  if (roll < 0.25){
    type = 'heart';
  } else if (roll < 0.42){
    type = 'bomb';
  } else if (roll < 0.68){
    const arsenal = ['fire','ice','lightning'];
    type = arsenal[Math.floor(Math.random()*arsenal.length)];
  } else if (roll < 0.88){
    const boosts = ['rapid','fury','focus'];
    type = boosts[Math.floor(Math.random()*boosts.length)];
  } else {
    type = Math.random()<0.5 ? 'mirror' : 'shadows';
  }
  const minX = 60, maxX = window.innerWidth - 80;
  const minY = 80, maxY = window.innerHeight - 120;
  const dropX = Math.max(minX, Math.min(maxX, boss.x + boss.width/2 + (Math.random()-0.5)*240));
  const dropY = Math.max(minY, Math.min(maxY, boss.y + boss.height + 60 + Math.random()*120));
  collectables.push(new Collectable(dropX, dropY, type));
}

function spawnMirrorDecoys(){
  if (!player) return;
  clones.push(new MirrorClone('mirror', { offset: -0.5, radius: 90, lag: 6 }));
  clones.push(new MirrorClone('mirror', { offset: 0.5, radius: 90, lag: 6 }));
  while (clones.length>6) clones.shift();
  floatTexts.push(new FloatText(player.x-60, player.y-100, 'Mirror Images!', '#a6c8ff'));
}

function spawnShadowSwarm(){
  if (!player) return;
  const count = 4;
  for (let i=0;i<count;i++){
    clones.push(new MirrorClone('swarm', { offset: (Math.PI*2*i)/count, radius: 60, lag: 10, scale:0.65, alpha:0.45 }));
  }
  while (clones.length>8) clones.shift();
  floatTexts.push(new FloatText(player.x-70, player.y-110, 'Shadow Swarm!', '#dcb8ff'));
}

/* ========= Backgrounds ========= */
const layerHueOffsets=[0, Math.random()*60-30, Math.random()*60-30, Math.random()*60-30];
const bgObjs = [
  new Background(bgLayers[0], 0, 0, layerHueOffsets[0]),
  new Background(bgLayers[1], 0.2, 0.5, layerHueOffsets[1]),
  new Background(bgLayers[2], 0.5, 1.0, layerHueOffsets[2]),
  new Background(bgLayers[3], 1.0, 1.2, layerHueOffsets[3])
];

/* ========= Core Loop ========= */
function resetGame(){
  player = new Player();
  projectiles = [];
  enemies = [];
  collectables = [];
  effects = [];
  floatTexts = [];
  particles = [];
  weatherParticles = [];
  bossProjectiles = [];
  bossSigils = [];
  bossHazards = [];
  clones = [];
  enemySpawnTimer = 0;
  cameraShake = 0;
  bgHue = 0; bgHueTimer = 0;
  dayHue = 0; worldBrightness = 1; timeOfDay = 0;
  lightningFlash = 0; setWeather();
  boss = null; bossSpawnTimer = 60*60 + Math.random()*60*60;
  killCount = 0;
  gameOver = false;
  bossDropTimer = 0;
}

function update(dt){
  const dir = player && player.vx < -0.1 ? -1 : 1;
  if (bgHueTimer>0){ bgHue = (bgHue + 2*dt) % 360; bgHueTimer -= dt; } else { bgHue = 0; }

  timeOfDay = (timeOfDay + dt) % dayCycle;
  const p = timeOfDay / dayCycle;
  worldBrightness = 0.5 + 0.5*Math.sin(p*2*Math.PI);
  dayHue = 20*Math.sin(p*2*Math.PI);

  updateWeather(dt);
  bgObjs.forEach(bg=>bg.update(dir, dt));

  player.update(dt);

  for (let ci=clones.length-1; ci>=0; ci--){
    const clone=clones[ci];
    clone.update(dt);
    if (clone.life<=0 || clone.hp<=0) clones.splice(ci,1);
  }

  for (let i=projectiles.length-1;i>=0;i--){ const pj=projectiles[i]; pj.update(dt); if (pj.life<=0) projectiles.splice(i,1); }
  for (let i=effects.length-1;i>=0;i--){ const ef=effects[i]; ef.update(dt); if (ef.life<=0) effects.splice(i,1); }
  resolveBouncyProjectiles();

    outerEnemyLoop:
    for (let ei=enemies.length-1; ei>=0; ei--){
      const e=enemies[ei];
      e.update(dt);
      if (e.hp<=0){ defeatEnemy(e, ei); continue; }
      if (e.x + e.width < 0) { enemies.splice(ei,1); continue; }

      if (player.x < e.x+e.width && player.x+player.width > e.x && player.y < e.y+e.height && player.y+player.height > e.y){
        player.takeDamage(); enemies.splice(ei,1); continue;
      }

      for (let ci=clones.length-1; ci>=0; ci--){
        const clone = clones[ci];
        if (clone && clone.intersects(e.x, e.y, e.width, e.height)){
          clone.takeDamage(1);
          spawnHitParticles(clone.x + (player.width||64)/2, clone.y, 'bomb');
          enemies.splice(ei,1);
          continue outerEnemyLoop;
        }
      }

      for (let pi=projectiles.length-1; pi>=0; pi--){
        const p=projectiles[pi];
        if (p.x < e.x + e.width && p.x > e.x && p.y > e.y && p.y < e.y + e.height){
          const impact = p.applyHit(e);
          spawnHitParticles(p.x,p.y, impact.element || 'default');
          if (impact.aoeRadius>0) applyAoeDamage(p.x, p.y, impact.aoeRadius, impact.damage*0.6, impact.element, e);
          sfxHit.currentTime=0; sfxHit.play();
          if (e.hp<=0){
            if (impact.splinter) spawnSplinters(e.x+e.width/2, e.y+e.height/2, impact.splinter, impact.stats);
            defeatEnemy(e, ei);
            break;
          }
          if (impact.remove){
            projectiles.splice(pi,1);
          }
        }
      }
    }

  if(boss){
    boss.shieldActive = bossSigils.length>0;
    boss.update(dt);
    bossDropTimer -= dt;
    if (bossDropTimer<=0){
      spawnBossDrop();
      const base = 240 - (boss.phase||1)*18;
      bossDropTimer = Math.max(160, base) + Math.random()*120;
    }
    for (let si=bossSigils.length-1; si>=0; si--){
      const sig=bossSigils[si];
      if (!boss){ bossSigils=[]; break; }
      sig.update(dt);
    }
    if (player.x < boss.x+boss.width && player.x+player.width > boss.x && player.y < boss.y+boss.height && player.y+player.height > boss.y){
      player.takeDamage();
    }
    for (let ci=clones.length-1; ci>=0; ci--){
      const clone = clones[ci];
      if (clone && clone.intersects(boss.x, boss.y, boss.width, boss.height)){
        clone.takeDamage(2);
        spawnHitParticles(clone.x + (player.width||64)/2, clone.y, 'bomb');
      }
    }
      for (let pi=projectiles.length-1; pi>=0; pi--){
        const p=projectiles[pi];
        let consumed=false;
        for (let si=bossSigils.length-1; si>=0; si--){
          const sig=bossSigils[si];
          const dist=Math.hypot((p.x||0) - sig.x, (p.y||0) - sig.y);
          if (dist < sig.size/2 + 6){
            const dmg = Math.max(1, Math.round(p.damage || p.sourceStats?.damage || 1));
            const destroyed = sig.takeDamage(dmg);
            if (typeof p.pierce !== 'number') p.pierce = 0;
            p.pierce -= 1;
            const remove = p.pierce < 0;
            if (remove) projectiles.splice(pi,1);
            else { p.x += (p.vx||0)*0.1; p.y += (p.vy||0)*0.1; }
            consumed = true;
            sfxHit.currentTime=0; sfxHit.play();
            if (destroyed){
              bossSigils.splice(si,1);
              if (bossSigils.length===0){
                boss.shieldActive=false;
                floatTexts.push(new FloatText(window.innerWidth/2 - 110, 100, 'Shield Shattered!', '#ffe6ff'));
                cameraShake = Math.max(cameraShake, 12);
              }
            }
            break;
          }
        }
        if (consumed) continue;
        if (p.x < boss.x + boss.width && p.x > boss.x && p.y > boss.y && p.y < boss.y + boss.height){
          if (bossSigils.length>0){
            spawnHitParticles(p.x,p.y,'lightning');
            sfxHit.currentTime=0; sfxHit.play();
            if (typeof p.pierce !== 'number') p.pierce = 0;
            p.pierce -= 1;
            if (p.pierce < 0) projectiles.splice(pi,1);
            else { p.x += (p.vx||0)*0.1; p.y += (p.vy||0)*0.1; }
            continue;
          }
          const dmg = p.damage || p.sourceStats?.damage || 1;
          boss.hp -= dmg;
          spawnHitParticles(p.x,p.y,'default');
          sfxHit.currentTime=0; sfxHit.play();
          if (typeof p.pierce !== 'number') p.pierce = 0;
          p.pierce -= 1;
          if (p.pierce < 0) projectiles.splice(pi,1);
          else { p.x += (p.vx||0)*0.1; p.y += (p.vy||0)*0.1; }
          if (boss.hp<=0){
            const bx=boss.x+boss.width/2, by=boss.y+boss.height/2;
            spawnExplosion(bx, by);
            spawnBlood(bx, by);
            spawnShockwave(bx, by);
            player.bonusShots++;
            boss=null; bossSigils=[]; bossHazards=[];
            bossDropTimer = 0;
            bossSpawnTimer = 60*60 + Math.random()*60*60; setWeather(); weatherParticles=[]; cameraShake=20;
            break;
        }
      }
    }
  } else {
    if (bossSpawnTimer<=0) { spawnBoss(); }
    else bossSpawnTimer-=dt;
    if (enemySpawnTimer<=0){ enemies.push(new Enemy()); enemySpawnTimer=90; } else enemySpawnTimer-=dt;
  }

  for(let bi=bossProjectiles.length-1; bi>=0; bi--){
    const b=bossProjectiles[bi];
    b.update(dt);
    let destroyed=false;
    for (let pi=projectiles.length-1; pi>=0; pi--){
      const p=projectiles[pi];
      if (!p) continue;
      const dist = Math.hypot((p.x||0) - b.x, (p.y||0) - b.y);
      if (dist < b.size + (p.size || 6)){
        const dmg = Math.max(0.5, p.damage || p.sourceStats?.damage || 1);
        if (b.takeDamage(dmg)){
          spawnHitParticles(b.x, b.y, 'bomb');
          bossProjectiles.splice(bi,1);
          destroyed=true;
        }
        if (p.bounceOnEnemies && p.bounces>0){
          p.bounces = Math.max(0, p.bounces-1);
          p.vx *= -1; p.vy *= -1;
          p.x += p.vx*0.1; p.y += p.vy*0.1;
        } else {
          p.pierce = (p.pierce||0) - 1;
          if (p.pierce < 0) projectiles.splice(pi,1);
        }
        playShootSound('bounce', { volume: 0.28 });
        spawnHitParticles(b.x, b.y, 'default');
        break;
      }
    }
    if (destroyed) continue;
    for (let ci=clones.length-1; ci>=0; ci--){
      const clone = clones[ci];
      if (clone && clone.intersects(b.x-b.size, b.y-b.size, b.size*2, b.size*2)){
        clone.takeDamage(1);
        spawnHitParticles(clone.x + (player.width||64)/2, clone.y, 'bomb');
        bossProjectiles.splice(bi,1);
        destroyed=true;
        break;
      }
    }
    if (destroyed) continue;
    if (player.x < b.x+b.size && player.x+player.width > b.x && player.y < b.y+b.size && player.y+player.height > b.y){
      player.takeDamage(); bossProjectiles.splice(bi,1); continue;
    }
    if (b.x < -50 || b.x > window.innerWidth+50 || b.y < -50 || b.y > window.innerHeight+50) bossProjectiles.splice(bi,1);
  }

  for (let hi=bossHazards.length-1; hi>=0; hi--){
    const h=bossHazards[hi]; h.update(dt);
    if (h.hitPlayer(player)) player.takeDamage();
    for (let ci=clones.length-1; ci>=0; ci--){
      const clone = clones[ci];
      if (!clone) continue;
      const bounds = clone.getBounds();
      if (h.hitPlayer({ x: bounds.x, y: bounds.y, width: bounds.width, height: bounds.height })){
        clone.takeDamage(2);
        spawnHitParticles(clone.x + (player.width||64)/2, clone.y, 'bomb');
      }
    }
    if (h.done) bossHazards.splice(hi,1);
  }

    for (let ci=collectables.length-1; ci>=0; ci--){
      const c=collectables[ci]; c.update(dt);
      if (player.x < c.x+c.size && player.x+player.width > c.x && player.y < c.y+c.size && player.y+player.height > c.y){
        if (c.type==='heart'){ if (player.hp<5) player.hp++; }
        else if (weaponDefinitions[c.type]){ player.upgradeWeapon(c.type); bgHueTimer = 140; }
        else if (powerUpDefinitions[c.type]){ player.applyPowerUp(c.type); bgHueTimer = Math.max(bgHueTimer, 90); }
        else if (c.type==='mirror'){ spawnMirrorDecoys(); }
        else if (c.type==='shadows'){ spawnShadowSwarm(); }
        else if (c.type==='bomb'){ player.bombs = Math.min(player.bombs+1, 5); floatTexts.push(new FloatText(player.x-20, player.y-80, 'Bomb Ready', '#ffb0ff')); }
        sfxPickup.currentTime=0; sfxPickup.play();
        collectables.splice(ci,1);
      }
    }

  if (cameraShake>0) cameraShake-=dt;
}

function draw(){
  const sx = cameraShake ? Math.random()*cameraShake - cameraShake/2 : 0;
  const sy = cameraShake ? Math.random()*cameraShake - cameraShake/2 : 0;
  ctx.save(); ctx.translate(sx,sy);
  ctx.clearRect(0,0,window.innerWidth,window.innerHeight);
  bgObjs.forEach(bg=>bg.draw());
  clones.forEach(c=>c.draw());
  player.draw();
  projectiles.forEach(p=>p.draw());
  effects.forEach(e=>e.draw());
  enemies.forEach(e=>e.draw());
  if(boss) boss.draw();
  bossSigils.forEach(s=>s.draw());
  bossHazards.forEach(h=>h.draw());
  bossProjectiles.forEach(b=>b.draw());
  collectables.forEach(c=>c.draw());
  drawParticles(frameDt);
  drawWeather();
  for (let i=floatTexts.length-1;i>=0;i--){ const ft=floatTexts[i]; ft.update(frameDt); if (ft.life<=0) floatTexts.splice(i,1); else ft.draw(); }
  ctx.restore();
}

function drawStartScreen(){
  ctx.fillStyle='black'; ctx.fillRect(0,0,window.innerWidth,window.innerHeight);
  ctx.fillStyle='white'; ctx.font='48px sans-serif'; ctx.textAlign='center';
  ctx.fillText('Wizard Carpet Quest', window.innerWidth/2, window.innerHeight/2 - 40);
  ctx.font='24px sans-serif';
  ctx.fillText(gameOver ? 'Game Over  Tap/Press to Restart' : 'Tap/Press Any Key to Start', window.innerWidth/2, window.innerHeight/2 + 20);
}

function loop(t){
  if(!lastTime) lastTime = t;
  const dt = Math.min(2, (t - lastTime) / 16.6667);
  lastTime = t;
  frameDt = dt;
  if (!started || gameOver) drawStartScreen();
  else { update(dt); draw(); }
  requestAnimationFrame(loop);
}
resetGame();
requestAnimationFrame(loop);
</script>
</body>
</html>
