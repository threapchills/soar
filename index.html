<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Wizard Carpet Quest</title>
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no, viewport-fit=cover">
<link rel="icon" type="image/png" href="assets/wizard_shoot.png">
<style>
  :root { --ui-fade: 0.35 }
  html, body { height:100%; }
  body { margin:0; overflow:hidden; background:black; touch-action:none; }
  canvas { display:block; background:black; width:100vw; height:100vh; }

  /* Mobile HUD (hidden on non-touch) */
  .hud { position:fixed; inset:0; pointer-events:none; display:none; }
  .touch .hud { display:block; }
  .stick {
    position: fixed;
    width: 140px; height: 140px; border-radius: 50%;
    background: radial-gradient(circle at 50% 50%, rgba(255,255,255,0.08), rgba(255,255,255,0.02));
    border: 1px solid rgba(255,255,255,0.2);
    pointer-events:auto; opacity: var(--ui-fade);
  }
  .pad {
    position:absolute; left:50%; top:50%; transform:translate(-50%,-50%);
    width: 70px; height:70px; border-radius:50%;
    background: rgba(255,255,255,0.15); border:1px solid rgba(255,255,255,0.3);
  }
  .left-stick { left: 20px; bottom: 24px; }
  .right-stick { right: 20px; bottom: 24px; }
</style>
</head>
<body>
<canvas id="game"></canvas>
<div class="hud" id="hud">
  <div class="stick left-stick" id="stickL"><div class="pad" id="padL"></div></div>
  <div class="stick right-stick" id="stickR"><div class="pad" id="padR"></div></div>
</div>

<script>
/* ========= Canvas & DPI ========= */
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
function resizeCanvas(){
  const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1)); // cap at 2x for perf
  const w = Math.floor(window.innerWidth);
  const h = Math.floor(window.innerHeight);
  canvas.style.width = w + 'px';
  canvas.style.height = h + 'px';
  canvas.width = Math.floor(w * dpr);
  canvas.height = Math.floor(h * dpr);
  ctx.setTransform(dpr,0,0,dpr,0,0); // use CSS pixels as logical units
}
resizeCanvas();
window.addEventListener('resize', resizeCanvas);

/* ========= Input (desktop) ========= */
let keys = {};
let mouse = { x: window.innerWidth/2, y: window.innerHeight/2, down: false };
window.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true, {passive:false});
window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false, {passive:false});
window.addEventListener('mousemove', e => { mouse.x = e.clientX; mouse.y = e.clientY; }, {passive:true});
window.addEventListener('mousedown', () => mouse.down = true, {passive:false});
window.addEventListener('mouseup', () => mouse.down = false, {passive:false});

/* ========= Touch detection & dual sticks ========= */
const isTouch = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
if (isTouch) document.documentElement.classList.add('touch');
const hud = document.getElementById('hud');
const stickL = document.getElementById('stickL'), padL = document.getElementById('padL');
const stickR = document.getElementById('stickR'), padR = document.getElementById('padR');

let leftStick = { active:false, dx:0, dy:0 };
let rightStick = { active:false, dx:0, dy:0 };

function stickBounds(el){ const r = el.getBoundingClientRect(); return {x:r.left + r.width/2, y:r.top + r.height/2, rad: r.width*0.5}; }
function handleStickTouch(e){
  e.preventDefault();
  const touches = e.touches ? Array.from(e.touches) : [];
  leftStick.active = rightStick.active = false; leftStick.dx=leftStick.dy=rightStick.dx=rightStick.dy=0;

  const lb = stickBounds(stickL), rb = stickBounds(stickR);
  touches.forEach(t=>{
    const x=t.clientX, y=t.clientY;
    const dl = Math.hypot(x-lb.x, y-lb.y);
    const dr = Math.hypot(x-rb.x, y-rb.y);
    if (dl < lb.rad) {
      leftStick.active = true;
      const ang = Math.atan2(y-lb.y, x-lb.x);
      const mag = Math.min(1, dl/lb.rad);
      leftStick.dx = Math.cos(ang)*mag;
      leftStick.dy = Math.sin(ang)*mag;
      padL.style.transform = `translate(${(leftStick.dx*lb.rad*0.4)}px, ${(leftStick.dy*lb.rad*0.4)}px)`;
    } else if (dr < rb.rad) {
      rightStick.active = true;
      const ang = Math.atan2(y-rb.y, x-rb.x);
      const mag = Math.min(1, dr/rb.rad);
      rightStick.dx = Math.cos(ang)*mag;
      rightStick.dy = Math.sin(ang)*mag;
      padR.style.transform = `translate(${(rightStick.dx*rb.rad*0.4)}px, ${(rightStick.dy*rb.rad*0.4)}px)`;

      // Aim vector => synthetic mouse
      mouse.x = player ? player.x + Math.cos(ang)*300 : x;
      mouse.y = player ? player.y + Math.sin(ang)*300 : y;
      mouse.down = mag > 0.2; // hold to shoot (deadzone)
    }
  });

  // Map left stick to WSAD booleans
  keys['w'] = leftStick.active && (leftStick.dy < -0.3);
  keys['s'] = leftStick.active && (leftStick.dy >  0.3);
  keys['a'] = leftStick.active && (leftStick.dx < -0.3);
  keys['d'] = leftStick.active && (leftStick.dx >  0.3);

  if (!rightStick.active) { mouse.down = false; padR.style.transform='translate(-50%,-50%)'; }
  if (!leftStick.active)  { padL.style.transform='translate(-50%,-50%)'; }
}
if (isTouch) {
  ['touchstart','touchmove','touchend','touchcancel'].forEach(evt=>{
    window.addEventListener(evt, handleStickTouch, {passive:false});
  });
}

/* ========= Assets ========= */
function loadImage(src) { const img = new Image(); img.src = src; return img; }
const bgLayers = [
  loadImage('assets/bg0.png'), // static sky
  loadImage('assets/bg1.png'),
  loadImage('assets/bg2.png'),
  loadImage('assets/bg3.png')
];
const wizardFly = loadImage('assets/wizard_fly.png');
const wizardShoot = loadImage('assets/wizard_shoot.png');
const enemiesSprites = [
  loadImage('assets/enemy1.png'),
  loadImage('assets/enemy2.png'),
  loadImage('assets/enemy3.png')
];
const orbSprite = loadImage('assets/orb.png');
const heartSprite = loadImage('assets/heart.png');

const song = new Audio('assets/song.ogg'); song.loop = true; song.volume = 0.0;
const sfxShoot = new Audio('assets/shoot.wav');
const sfxHit = new Audio('assets/hit.wav');
const sfxPickup = new Audio('assets/pickup.wav');

/* ========= Game State ========= */
let started=false, gameOver=false, cameraShake=0;
let bgHue=0, bgHueTimer=0;
let dayHue=0, worldBrightness=1, timeOfDay=0, dayCycle=120*60;
let weather='clear', weatherTimer=0, weatherParticles=[], lightningFlash=0;
let player, projectiles, enemies, particles, collectables, effects, floatTexts, enemySpawnTimer, boss, bossProjectiles, bossSigils, bossHazards, bossSpawnTimer, killCount;
bossSigils = [];
bossHazards = [];
let lastTime = 0, frameDt = 1;


const hueMap = { fire: 0, lightning: 220, ice: 180 };
const weaponStats = {
  default:   { cooldown: 15, speed: 10, damage: 1 },
  fire:      { cooldown: 25, speed:  6, damage: 2 },
  lightning: { cooldown: 30, speed:  0, damage: 2 }, // hitscan
  ice:       { cooldown: 22, speed:  8, damage: 1 }
};

/* ========= Start / Music ========= */
function startGame(){
  if (!started) { started=true; fadeInMusic(); resetGame(); }
  else if (gameOver) { resetGame(); }
}
function fadeInMusic(){
  song.currentTime=0;
  song.play().catch(()=>{});
  let vol=0;
  const fade = setInterval(()=>{
    vol += 0.02; song.volume = Math.min(vol, 0.4);
    if (song.volume >= 0.4) clearInterval(fade);
  },100);
}
window.addEventListener('click', startGame, {passive:true});
window.addEventListener('keydown', startGame, {passive:true});
window.addEventListener('touchstart', startGame, {passive:true});

function setWeather(){
  const types=['clear','rain','snow','sand','wind'];
  weather = types[Math.floor(Math.random()*types.length)];
  weatherTimer = 600 + Math.random()*1200;
}

function setTempestWeather(){
  weather = 'tempest';
  weatherTimer = 900;
  weatherParticles = [];
  lightningFlash = 10;
}

/* ========= Classes ========= */
class Background{
  constructor(img,speed,hueMult=1,baseHue=0){ this.img=img; this.speed=speed; this.x=0; this.hueMult=hueMult; this.baseHue=baseHue; }
  update(dir,dt){

    if (this.speed===0) return; // bg0 static
    this.x -= this.speed * (dir>=0 ? 1 : -1) * dt; // reverse cosmetically when moving left
    const w = window.innerWidth;
    if (this.x <= -w) this.x += w;
    if (this.x >=  w) this.x -= w;
  }
  draw(){
    const w = window.innerWidth, h = window.innerHeight;
    ctx.save();
    const hue = this.baseHue + dayHue + bgHue * this.hueMult;
    ctx.filter = `hue-rotate(${hue}deg) brightness(${worldBrightness})`;
    ctx.drawImage(this.img, this.x, 0, w, h);
    if (this.speed!==0){
      ctx.drawImage(this.img, this.x + w, 0, w, h);
      ctx.drawImage(this.img, this.x - w, 0, w, h);
    }
    ctx.restore();
  }
}

class Player{
  constructor(){
    this.x = window.innerWidth/4;
    this.y = window.innerHeight/2;
    this.width=64; this.height=32;
    this.vx=0; this.vy=0; this.accel=0.4; this.maxSpeed=5;
    this.bob=0; this.flip=false;
    this.hp=5; this.invuln=0;
    this.bonusShots=0;
    this.weapon='default';
    this.cooldownTimer=0;
  }
  update(dt){
    if (this.invuln>0) this.invuln -= dt;
    let tx=0, ty=0;
    if (keys['w']) ty -= this.accel*dt;
    if (keys['s']) ty += this.accel*dt;
    if (keys['a']) { tx -= this.accel*dt; this.flip = true; }
    if (keys['d']) { tx += this.accel*dt; this.flip = false; }
    this.vx = (this.vx + tx) * Math.pow(0.9, dt);
    this.vy = (this.vy + ty) * Math.pow(0.9, dt);
    this.vx = Math.max(-this.maxSpeed, Math.min(this.maxSpeed, this.vx));
    this.vy = Math.max(-this.maxSpeed, Math.min(this.maxSpeed, this.vy));
    this.x += this.vx*dt; this.y += this.vy*dt;

    // Horizontal wrap; vertical clamped
    const halfW=this.width/2, halfH=this.height/2;
    if (this.x < -halfW) this.x = window.innerWidth + halfW;
    if (this.x > window.innerWidth + halfW) this.x = -halfW;
    this.y = Math.max(halfH, Math.min(window.innerHeight - halfH, this.y));

    // bob
    this.bob += 0.05*dt; this.y += Math.sin(this.bob)*0.3*dt;

    // shooting with cooldown
    if (mouse.down && this.cooldownTimer<=0){
      this.shoot();
      this.cooldownTimer = weaponStats[this.weapon].cooldown;
    }
    if (this.cooldownTimer>0) this.cooldownTimer -= dt;
  }
  shoot(){
    sfxShoot.currentTime=0; sfxShoot.play();
    const angle = Math.atan2(mouse.y - this.y, mouse.x - this.x);
    const shots = 1 + this.bonusShots;
    if (this.weapon==='default' || this.weapon==='ice' || this.weapon==='fire'){
      for(let i=0;i<shots;i++){
        const spread = (i-(shots-1)/2)*0.1;
        projectiles.push(new Projectile(this.x+this.width/2, this.y, angle+spread, this.weapon));
      }
    } else if (this.weapon==='lightning'){
      for(let i=0;i<shots;i++){
        const spread = (i-(shots-1)/2)*0.1;
        effects.push(new LightningEffect(this.x+this.width/2, this.y, angle+spread));
      }
    }
    for (let i=0;i<8;i++) particles.push(makeParticle(this.x+this.width/2, this.y, '255,220,150', 2));
    cameraShake = Math.max(cameraShake,2);
  }
  takeDamage(){ if (this.invuln>0) return; this.hp--; this.invuln=30; this.bonusShots=0; if (this.hp<=0) gameOver=true; }
  draw(){
    ctx.save();
    ctx.translate(this.x, this.y);
    if (this.flip){ ctx.scale(-1,1); ctx.translate(-this.width, 0); }
    if (this.invuln%6<3){
      const img = (mouse.down && this.cooldownTimer > weaponStats[this.weapon].cooldown/2) ? wizardShoot : wizardFly;
      ctx.drawImage(img, 0, -this.height/2, this.width, this.height);
    }
    ctx.restore();
    // HP UI
    ctx.fillStyle='red'; ctx.fillRect(20,20, this.hp*30, 10);
    ctx.strokeStyle='white'; ctx.strokeRect(20,20, 5*30, 10);
  }
}

class Projectile{
  constructor(x,y,angle,type){
    this.x=x; this.y=y; this.type=type;
    this.speed=weaponStats[type].speed;
    this.vx=Math.cos(angle)*this.speed;
    this.vy=Math.sin(angle)*this.speed;
    this.size=6; this.life=60;
    this.color = (type==='fire')?'255,120,0':(type==='ice')?'150,200,255':'255,255,150';
  }
  update(dt){
    this.x+=this.vx*dt; this.y+=this.vy*dt; this.life-=dt;
    const trail = makeParticle(this.x, this.y, this.color, 2);
    trail.vx *= 0.2; trail.vy *= 0.2; trail.life = 20;
    particles.push(trail);
  }
  draw(){
    ctx.save(); ctx.globalCompositeOperation='lighter';
    ctx.fillStyle=`rgba(${this.color},0.15)`; ctx.beginPath(); ctx.arc(this.x,this.y,this.size*2.4,0,Math.PI*2); ctx.fill();
    ctx.fillStyle=`rgba(${this.color},1)`; ctx.beginPath(); ctx.arc(this.x,this.y,this.size,0,Math.PI*2); ctx.fill();
    ctx.restore();
  }
}

class LightningEffect{
  constructor(x,y,angle){
    this.x=x; this.y=y; this.angle=angle; this.life=6; this.hitApplied=false;
    this.targets=findLightningTargets(this.x,this.y,this.angle);
  }
  update(dt){
    if (!this.hitApplied){
      this.targets.forEach((t,i)=>{
        if (!t) return;
        const dmg = i===0?2:1;
        t.hp -= dmg;
        spawnHitParticles(t.x+t.width/2, t.y+t.height/2, 'lightning');
        if (t.hp<=0){
          spawnExplosion(t.x+t.width/2, t.y+t.height/2);
          dropCollectable(t.x,t.y);
          enemies.splice(enemies.indexOf(t),1);
          cameraShake=10;
        }
      });
      sfxHit.currentTime=0; sfxHit.play();
      this.hitApplied=true;
    }
    this.life-=dt;
  }
  draw(){
    if (this.targets.length===0) return;
    ctx.save(); ctx.globalCompositeOperation='lighter';
    ctx.strokeStyle='rgba(120,200,255,0.9)'; ctx.lineWidth=2;
    ctx.beginPath(); ctx.moveTo(this.x,this.y);
    this.targets.forEach(t=>{
      if (!t) return;
      const tx=t.x+t.width/2, ty=t.y+t.height/2;
      const seg=6; for (let i=1;i<=seg;i++){
        const p=i/seg;
        const ix=this.x+(tx-this.x)*p + (Math.random()-0.5)*8;
        const iy=this.y+(ty-this.y)*p + (Math.random()-0.5)*8;
        ctx.lineTo(ix,iy);
      }
    });
    ctx.stroke(); ctx.restore();
  }
}

class BossProjectile{
  constructor(x,y,tx,ty,opts={}){
    this.x=x; this.y=y;
    const speed = opts.speed || 4;
    const ang=Math.atan2(ty-y, tx-x);
    this.vx=Math.cos(ang)*speed; this.vy=Math.sin(ang)*speed;
    this.size=opts.size || 8;
    this.color=opts.color || 'rgba(255,50,50,1)';
    this.seek=opts.seek || 0;
    this.wobble=opts.wobble || 0;
    this.time=0;
  }

  update(dt){
    this.time += dt;
    if (this.seek && player){
      const ang = Math.atan2(player.y - this.y, player.x - this.x);
      this.vx += Math.cos(ang) * this.seek * 0.002 * dt;
      this.vy += Math.sin(ang) * this.seek * 0.002 * dt;
    }
    if (this.wobble){
      const mag = Math.hypot(this.vx,this.vy);
      const wob = Math.sin(this.time * 0.1 * this.wobble) * 0.2;
      const ang = Math.atan2(this.vy,this.vx) + wob * dt;
      this.vx = Math.cos(ang) * mag;
      this.vy = Math.sin(ang) * mag;
    }
    this.x+=this.vx*dt; this.y+=this.vy*dt;
  }

  draw(){
    ctx.save();
    ctx.fillStyle=this.color;
    ctx.beginPath(); ctx.arc(this.x,this.y,this.size,0,Math.PI*2); ctx.fill();
    ctx.restore();
  }
}

class BossSigil{
  constructor(boss,angle){
    this.boss=boss;
    this.angle=angle;
    this.radius=Math.max(boss.width,boss.height)*0.55 + 70;
    this.size=52;
    this.hp=10;
    this.spin=0.01 + Math.random()*0.02;
    this.flash=0;
  }
  update(dt){
    if (!this.boss) return;
    this.angle += this.spin*dt;
    const cx=this.boss.x+this.boss.width/2;
    const cy=this.boss.y+this.boss.height/2;
    this.x = cx + Math.cos(this.angle)*this.radius;
    this.y = cy + Math.sin(this.angle)*this.radius;
    if (this.flash>0) this.flash-=dt;
  }
  takeDamage(dmg){
    this.hp -= dmg;
    this.flash=12;
    spawnHitParticles(this.x,this.y,'lightning');
    if (this.hp<=0){
      spawnExplosion(this.x,this.y);
      return true;
    }
    return false;
  }
  draw(){
    if (!this.x && !this.y) return;
    ctx.save();
    ctx.translate(this.x,this.y);
    const pulse = 1 + Math.sin(perfNow()*3 + this.angle)*0.15;
    ctx.scale(pulse,pulse);
    if (this.flash>0){
      ctx.globalAlpha = Math.max(0.2, Math.min(1, this.flash/12));
    } else {
      ctx.globalAlpha = 0.8;
    }
    ctx.globalCompositeOperation='lighter';
    ctx.fillStyle='rgba(120,200,255,0.5)';
    ctx.beginPath(); ctx.arc(0,0,this.size/2,0,Math.PI*2); ctx.fill();
    ctx.globalCompositeOperation='source-over';
    ctx.globalAlpha=1;
    ctx.strokeStyle='rgba(255,255,255,0.85)';
    ctx.lineWidth=3;
    ctx.beginPath(); ctx.arc(0,0,this.size/2+6,0,Math.PI*2); ctx.stroke();
    ctx.restore();
  }
}

class BossLaser{
  constructor(orientation,pos){
    this.orientation=orientation;
    this.pos=pos;
    this.warning=90;
    this.duration=70;
    this.timer=0;
    this.active=false;
    this.done=false;
    this.width=orientation==='horizontal'?120:120;
  }
  update(dt){
    this.timer += dt;
    if (!this.active){
      if (this.timer >= this.warning){
        this.active=true;
        this.timer=0;
        cameraShake = Math.max(cameraShake, 8);
      }
    } else if (this.timer >= this.duration){
      this.done=true;
    }
  }
  hitPlayer(p){
    if (!this.active) return false;
    const half=this.width/2;
    if (this.orientation==='horizontal'){
      return p.y < this.pos + half && p.y + p.height > this.pos - half;
    }
    return p.x < this.pos + half && p.x + p.width > this.pos - half;
  }
  draw(){
    const half=this.width/2;
    const w=window.innerWidth, h=window.innerHeight;
    ctx.save();
    if (!this.active){
      ctx.fillStyle='rgba(120,200,255,0.18)';
      ctx.strokeStyle='rgba(255,255,255,0.4)';
      ctx.setLineDash([12,12]);
      ctx.lineWidth=2;
    } else {
      ctx.globalCompositeOperation='lighter';
      ctx.fillStyle='rgba(255,90,160,0.55)';
      ctx.shadowColor='rgba(255,120,220,0.9)';
      ctx.shadowBlur=30;
    }
    if (this.orientation==='horizontal'){
      ctx.fillRect(0, this.pos - half, w, this.width);
      if (!this.active) ctx.strokeRect(0, this.pos - half, w, this.width);
    } else {
      ctx.fillRect(this.pos - half, 0, this.width, h);
      if (!this.active) ctx.strokeRect(this.pos - half, 0, this.width, h);
    }
    ctx.restore();
  }
}

class Boss{
  constructor(type){
    this.type=type;
    this.sprite=enemiesSprites[type];
    this.width=384; this.height=384;
    this.x=window.innerWidth; this.y=window.innerHeight/2 - this.height/2;
    this.hp=200 + type*50; this.maxHp=this.hp;
    this.timer=0; this.anim=0; this.spiral=0;
    this.targetX = window.innerWidth - this.width - 80;
    this.phase=1;
    this.phase2Triggered=false;
    this.phase3Triggered=false;
    this.shieldPulse=0;
    this.shieldActive=false;
    this.laserTimer=240;
  }
  update(dt){
    this.timer+=dt; this.anim+=dt;
    this.x += (this.targetX - this.x)*0.02*dt;
    const cx=this.x+this.width/2, cy=this.y+this.height/2;
    this.shieldPulse = this.shieldActive ? Math.min(1, this.shieldPulse + 0.04*dt) : Math.max(0, this.shieldPulse - 0.05*dt);

    if (!this.phase2Triggered && this.hp <= this.maxHp*0.7){
      this.phase = 2;
      this.phase2Triggered = true;
      summonBossSigils(this);
      floatTexts.push(new FloatText(window.innerWidth/2 - 90, 80, 'Arcane Ward!', '#7fd9ff'));
      cameraShake = Math.max(cameraShake, 8);
      bgHueTimer = Math.max(bgHueTimer, 240);
    }

    if (!this.phase3Triggered && this.hp <= this.maxHp*0.4){
      this.phase = 3;
      this.phase3Triggered = true;
      this.laserTimer = 90;
      floatTexts.push(new FloatText(window.innerWidth/2 - 110, 120, 'Tempest Fury!', '#ff96d8'));
      cameraShake = Math.max(cameraShake, 14);
      spawnShockwave(cx, cy);
      summonBossSigils(this);
      setTempestWeather();
    }

    if(this.type===0){
      const wobble = 2 + this.phase;
      this.y += Math.sin(this.anim*(0.03 + this.phase*0.005)*60)*wobble*dt;
      const cooldown = this.phase===1?60:(this.phase===2?45:30);
      if(this.timer>=cooldown){
        const base=Math.atan2(player.y-cy, player.x-cx);
        for(let i=-2;i<=2;i++){
          const ang=base+i*0.2;
          const tx=cx+Math.cos(ang)*1000;
          const ty=cy+Math.sin(ang)*1000;
          const opts = { speed: 4 + this.phase*0.8, color: i===0?'rgba(255,180,120,1)':'rgba(255,80,80,1)' };
          if (this.phase>=3 && i===0) opts.seek = 5;
          bossProjectiles.push(new BossProjectile(cx,cy,tx,ty,opts));
        }
        if (this.phase>=2){
          const ang = base + (Math.random()-0.5)*0.6;
          const tx=cx+Math.cos(ang)*1000;
          const ty=cy+Math.sin(ang)*1000;
          bossProjectiles.push(new BossProjectile(cx,cy,tx,ty,{speed:6,color:'rgba(180,220,255,0.95)',seek:this.phase===3?6:0}));
        }
        this.timer=0;
      }
    } else if(this.type===1){
      const sway = 3 + this.phase*1.5;
      this.y += Math.sin(this.anim*(0.02 + this.phase*0.003)*60)*sway*dt;
      const cooldown = this.phase===1?150:(this.phase===2?120:90);
      if(this.timer>=cooldown){
        const burst = this.phase>=3?14:10;
        for(let i=0;i<burst;i++){
          const ang=(i/burst)*Math.PI*2;
          const tx=cx+Math.cos(ang)*1000;
          const ty=cy+Math.sin(ang)*1000;
          const opts = { speed: 3.5 + this.phase*0.6, color:'rgba(255,160,90,0.95)' };
          bossProjectiles.push(new BossProjectile(cx,cy,tx,ty,opts));
        }
        if (this.phase>=2) spawnBossMinions(this, this.phase===3?3:2);
        if (this.phase===3){
          bossProjectiles.push(new BossProjectile(cx,cy,player.x,player.y,{speed:5.5,color:'rgba(255,220,120,0.9)',seek:4}));
        }
        this.timer=0;
      }
    } else if(this.type===2){
      const drift = 3 + this.phase;
      this.y += Math.sin(this.anim*(0.04 + this.phase*0.008)*60)*drift*dt;
      this.spiral += (0.2 + this.phase*0.05)*dt;
      const cooldown = this.phase===1?15:(this.phase===2?10:6);
      if(this.timer>=cooldown){
        const ang=this.spiral;
        const tx=cx+Math.cos(ang)*1000;
        const ty=cy+Math.sin(ang)*1000;
        const opts = { speed: 4 + this.phase*0.9, color:'rgba(180,130,255,0.95)', wobble:this.phase>=2?1.5:0 };
        bossProjectiles.push(new BossProjectile(cx,cy,tx,ty,opts));
        if (this.phase>=3){
          const ang2 = this.spiral + Math.PI;
          const tx2=cx+Math.cos(ang2)*1000;
          const ty2=cy+Math.sin(ang2)*1000;
          bossProjectiles.push(new BossProjectile(cx,cy,tx2,ty2,{speed:4.5,color:'rgba(120,200,255,0.9)',wobble:2.5}));
        }
        this.timer=0;
      }
    }
    this.y = Math.max(0, Math.min(window.innerHeight - this.height, this.y));
    if (this.phase>=3){
      this.laserTimer -= dt;
      if (this.laserTimer<=0){
        spawnBossLaser(Math.random()<0.5?'horizontal':'vertical');
        if (Math.random()<0.35) spawnBossLaser(Math.random()<0.5?'horizontal':'vertical');
        this.laserTimer = 220 - this.phase*40 + Math.random()*80;
      }
    }
  }
  draw(){
    ctx.drawImage(this.sprite, this.x, this.y, this.width, this.height);
    ctx.save();
    const barW=this.width, barH=10;
    ctx.fillStyle='rgba(0,0,0,0.5)';
    ctx.fillRect(this.x, this.y-barH-4, barW, barH);
    ctx.fillStyle='red';
    ctx.fillRect(this.x, this.y-barH-4, barW*(this.hp/this.maxHp), barH);
    ctx.strokeStyle='white'; ctx.strokeRect(this.x, this.y-barH-4, barW, barH);
    ctx.fillStyle='white'; ctx.font='16px sans-serif'; ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.fillText(this.hp, this.x+barW/2, this.y-barH-9);
    ctx.restore();
    if (this.shieldPulse>0){
      const cx=this.x+this.width/2, cy=this.y+this.height/2;
      const rad=Math.max(this.width,this.height)*0.6 + Math.sin(perfNow()*5)*6*this.shieldPulse;
      ctx.save();
      ctx.globalCompositeOperation='lighter';
      ctx.lineWidth=8*this.shieldPulse;
      ctx.strokeStyle=`rgba(120,200,255,${0.5*this.shieldPulse})`;
      ctx.beginPath(); ctx.arc(cx,cy,rad,0,Math.PI*2); ctx.stroke();
      ctx.restore();
    }
  }
}

class Enemy{
  constructor(){
    this.sprite = enemiesSprites[Math.floor(Math.random()*enemiesSprites.length)];
    this.width=96; this.height=96;

    // Spawn and baseline
    this.x = window.innerWidth + 50;
    this.y = Math.random()*(window.innerHeight - this.height);
    this.baseY = this.y;
    this.drift = (Math.random()*0.5 + 0.2) * (Math.random()<0.5 ? -1 : 1);

    // Movement/HP
    this.baseSpeed = 2 + Math.random()*1.5; // constant world speed
    this.hp = 3;

    // Zig-zag variety
    this.waveOffset = Math.random()*Math.PI*2;
    this.waveSpeed  = 0.005 + Math.random()*0.02;
    this.waveAmp    = 10 + Math.random()*110; // 10–120px amplitude

    this.slowTimer=0;
  }
  update(dt){
    const spd = this.slowTimer>0 ? this.baseSpeed*0.5 : this.baseSpeed;
    if (this.slowTimer>0) this.slowTimer-=dt;
    this.x -= spd*dt;

    // drift baseline up/down
    this.baseY += this.drift*dt;
    if (this.baseY < 0 || this.baseY > window.innerHeight - this.height) this.drift *= -1;

    // layered wobble around drifting baseline
    const t = perfNow();
    const wobble = Math.sin(t * this.waveSpeed + this.waveOffset) * this.waveAmp;
    const wobble2 = Math.sin(t * this.waveSpeed * 1.7 + this.waveOffset * 1.5) * this.waveAmp * 0.25;
    this.y = this.baseY + wobble + wobble2;

    // Stay in vertical bounds
    this.y = Math.max(0, Math.min(window.innerHeight - this.height, this.y));
  }
  draw(){ ctx.drawImage(this.sprite, this.x, this.y, this.width, this.height); }
}

class Collectable{
  constructor(x,y,type){ this.x=x; this.y=y; this.type=type; this.size=24; this.floatOffset=Math.random()*Math.PI*2; }
  update(dt){ this.x -= 2*dt; this.floatOffset += 0.05*dt; }
  draw(){
    const dy = Math.sin(this.floatOffset)*4;
    if (this.type==='heart') ctx.drawImage(heartSprite, this.x, this.y+dy, this.size, this.size);
    else { ctx.save(); ctx.filter=`hue-rotate(${hueMap[this.type]}deg)`; ctx.drawImage(orbSprite, this.x, this.y+dy, this.size, this.size); ctx.restore(); }
  }
}

class FloatText{
  constructor(x,y,text,color){ this.x=x; this.y=y; this.text=text; this.color=color; this.life=40; }
  update(dt){ this.y -= 0.5*dt; this.life-=dt; }
  draw(){ ctx.fillStyle=this.color; ctx.font='16px sans-serif'; ctx.fillText(this.text,this.x,this.y); }
}

/* ========= Particles ========= */
function spawnExplosion(x,y){
  for(let i=0;i<28;i++) particles.push(makeParticle(x,y,(Math.random()<0.6)?'255,120,0':'255,60,0',5));
}
function spawnBlood(x,y){
  for(let i=0;i<120;i++) particles.push(makeParticle(x,y,'150,0,0',6));
}
function spawnHitParticles(x,y,type='default'){
  let color='255,0,0', size=4;
  if (type==='fire'){ color='255,120,0'; size=5; }
  if (type==='ice'){ color='160,220,255'; size=3; }
  if (type==='lightning'){ color='120,200,255'; size=3; }
  for(let i=0;i<32;i++) particles.push(makeParticle(x,y,color,size));
}
function spawnShockwave(x,y){
  const ring=48;
  for(let i=0;i<ring;i++){
    const ang=(i/ring)*Math.PI*2;
    const speed=4 + Math.random()*2;
    const p=makeParticle(x,y,'220,220,255',4);
    p.vx = Math.cos(ang)*speed;
    p.vy = Math.sin(ang)*speed;
    p.life = 18 + Math.random()*18;
    particles.push(p);
  }
}
function makeParticle(x,y,color,size){
  return { x,y, vx:(Math.random()-0.5)*6, vy:(Math.random()-0.5)*6, life:24+Math.random()*12, size, color };
}
function drawParticles(dt){
  ctx.save(); ctx.globalCompositeOperation='lighter';
  for (let i=particles.length-1;i>=0;i--){
    const p=particles[i]; p.x+=p.vx*dt; p.y+=p.vy*dt; p.life-=dt;
    const a=Math.max(0,p.life/36);
    ctx.fillStyle=`rgba(${p.color},${a})`;
    ctx.beginPath(); ctx.arc(p.x,p.y,p.size,0,Math.PI*2); ctx.fill();
    if (p.life<=0) particles.splice(i,1);
  }
  ctx.restore();
}

function updateWeather(dt){
  if((weatherTimer-=dt)<=0) setWeather();
  const w=window.innerWidth, h=window.innerHeight;
  if(weather==='rain'){
    for(let i=0;i<5*dt;i++) weatherParticles.push({x:Math.random()*w, y:-10, vx:-2+Math.random(), vy:10+Math.random()*4, type:'rain', life:h});
  } else if(weather==='snow'){
    for(let i=0;i<2*dt;i++) weatherParticles.push({x:Math.random()*w, y:-10, vx:-1+Math.random()*2, vy:2+Math.random()*1, type:'snow', life:h});
  } else if(weather==='sand'){
    for(let i=0;i<4*dt;i++) weatherParticles.push({x:Math.random()*w, y:Math.random()*h, vx:-3-Math.random()*2, vy:Math.random()-0.5, type:'sand', life:200});
  } else if(weather==='wind'){
    for(let i=0;i<dt;i++) if(Math.random()<0.3) weatherParticles.push({x:Math.random()*w, y:Math.random()*h, vx:-2-Math.random()*2, vy:Math.random()-0.5, type:'leaf', rot:Math.random()*Math.PI, life:200});
  } else if(weather==='tempest'){
    for(let i=0;i<3*dt;i++) weatherParticles.push({x:Math.random()*w, y:-20, vx:(Math.random()-0.5)*3, vy:14+Math.random()*4, type:'tempest', life:h});
    if(Math.random()<0.004*dt){
      const x=Math.random()*w;
      weatherParticles.push({x, y:-40, vx:0, vy:18, type:'bolt', life:h});
    }
  }
  if((weather==='rain' || weather==='sand' || weather==='tempest') && Math.random()<0.002*dt) lightningFlash=5;
  for(let i=weatherParticles.length-1;i>=0;i--){
    const p=weatherParticles[i]; p.x+=p.vx*dt; p.y+=p.vy*dt; p.life-=dt;
    if(p.type==='rain') p.vy+=0.1*dt;
    if(p.type==='bolt') p.vy+=0.4*dt;
    if(p.life<=0 || p.y>h+20 || p.x<-20 || p.x>w+20) weatherParticles.splice(i,1);
  }
  lightningFlash = Math.max(0, lightningFlash - dt);
}

function drawWeather(){
  ctx.save();
  weatherParticles.forEach(p=>{
    if(p.type==='rain'){
      ctx.strokeStyle='rgba(160,160,255,0.6)';
      ctx.beginPath(); ctx.moveTo(p.x,p.y); ctx.lineTo(p.x+p.vx*2,p.y+p.vy*2); ctx.stroke();
    } else if(p.type==='snow'){
      ctx.fillStyle='rgba(255,255,255,0.8)';
      ctx.beginPath(); ctx.arc(p.x,p.y,2,0,Math.PI*2); ctx.fill();
    } else if(p.type==='sand'){
      ctx.fillStyle='rgba(194,178,128,0.7)';
      ctx.fillRect(p.x,p.y,2,2);
    } else if(p.type==='leaf'){
      ctx.fillStyle='rgba(200,150,50,0.8)';
      ctx.save(); ctx.translate(p.x,p.y); ctx.rotate(p.rot||0); ctx.fillRect(-3,-1,6,2); ctx.restore();
      p.rot += 0.05*frameDt;
    } else if(p.type==='tempest'){
      ctx.strokeStyle='rgba(180,150,255,0.5)';
      ctx.lineWidth=2;
      ctx.beginPath(); ctx.moveTo(p.x,p.y); ctx.lineTo(p.x+p.vx*2, p.y+p.vy*2); ctx.stroke();
    } else if(p.type==='bolt'){
      ctx.strokeStyle='rgba(255,220,255,0.85)';
      ctx.lineWidth=3;
      ctx.beginPath();
      ctx.moveTo(p.x, p.y);
      ctx.lineTo(p.x + (Math.random()-0.5)*30, p.y + 50);
      ctx.stroke();
    }
  });
  ctx.restore();
  if(lightningFlash>0){ ctx.fillStyle=`rgba(255,255,255,${lightningFlash/10})`; ctx.fillRect(0,0,window.innerWidth,window.innerHeight); }
}

/* ========= Helpers ========= */
function perfNow(){ return (performance || Date).now ? (performance.now()/1000) : (Date.now()/1000); }
function findLightningTargets(px,py,angle){
  return enemies
    .map(e=>({e, d: Math.hypot(e.x-px, e.y-py)}))
    .filter(o=>o.d<500)
    .sort((a,b)=>a.d-b.d)
    .slice(0,2)
    .map(o=>o.e);
}
function dropCollectable(x,y){
  const roll=Math.random();
  if (roll<0.2) collectables.push(new Collectable(x,y,'heart'));
  else if (roll<0.6){
    const types=['fire','lightning','ice'];
    collectables.push(new Collectable(x,y, types[Math.floor(Math.random()*types.length)]));
  }
}

function summonBossSigils(boss){
  bossSigils = [];
  const count = boss.phase>=3 ? 4 : 3;
  for(let i=0;i<count;i++) bossSigils.push(new BossSigil(boss, (Math.PI*2*i)/count));
  boss.shieldActive = true;
  cameraShake = Math.max(cameraShake, 6);
}

function spawnBossLaser(orientation,pos){
  const w=window.innerWidth, h=window.innerHeight;
  const placement = typeof pos==='number' ? pos : (orientation==='horizontal' ? (h*0.2 + Math.random()*h*0.6) : (w*0.2 + Math.random()*w*0.6));
  bossHazards.push(new BossLaser(orientation, placement));
}

function spawnBossMinions(boss,count){
  for(let i=0;i<count;i++){
    const minion=new Enemy();
    minion.x = boss.x - 80 - Math.random()*120;
    minion.y = boss.y + boss.height/2 + (Math.random()*160 - 80);
    minion.baseY = minion.y;
    minion.hp = 2 + Math.floor(Math.random()*2);
    minion.baseSpeed = 3 + Math.random()*1.5;
    enemies.push(minion);
  }
}

function spawnBoss(){
  boss = new Boss(Math.floor(Math.random()*enemiesSprites.length));
  weather = 'rain';
  weatherTimer = 1200;
  weatherParticles = [];
  lightningFlash = 8;
  killCount = 0;
  bossSigils = [];
  bossHazards = [];
}

/* ========= Backgrounds ========= */
const layerHueOffsets=[0, Math.random()*60-30, Math.random()*60-30, Math.random()*60-30];
const bgObjs = [
  new Background(bgLayers[0], 0, 0, layerHueOffsets[0]),
  new Background(bgLayers[1], 0.2, 0.5, layerHueOffsets[1]),
  new Background(bgLayers[2], 0.5, 1.0, layerHueOffsets[2]),
  new Background(bgLayers[3], 1.0, 1.2, layerHueOffsets[3])
];

/* ========= Core Loop ========= */
function resetGame(){
  player = new Player();
  projectiles = [];
  enemies = [];
  collectables = [];
  effects = [];
  floatTexts = [];
  particles = [];
  weatherParticles = [];
  bossProjectiles = [];
  bossSigils = [];
  bossHazards = [];
  enemySpawnTimer = 0;
  cameraShake = 0;
  bgHue = 0; bgHueTimer = 0;
  dayHue = 0; worldBrightness = 1; timeOfDay = 0;
  lightningFlash = 0; setWeather();
  boss = null; bossSpawnTimer = 60*60 + Math.random()*60*60;
  killCount = 0;
  gameOver = false;
}

function update(dt){
  const dir = player && player.vx < -0.1 ? -1 : 1;
  if (bgHueTimer>0){ bgHue = (bgHue + 2*dt) % 360; bgHueTimer -= dt; } else { bgHue = 0; }

  timeOfDay = (timeOfDay + dt) % dayCycle;
  const p = timeOfDay / dayCycle;
  worldBrightness = 0.5 + 0.5*Math.sin(p*2*Math.PI);
  dayHue = 20*Math.sin(p*2*Math.PI);

  updateWeather(dt);
  bgObjs.forEach(bg=>bg.update(dir, dt));

  player.update(dt);

  for (let i=projectiles.length-1;i>=0;i--){ const pj=projectiles[i]; pj.update(dt); if (pj.life<=0) projectiles.splice(i,1); }
  for (let i=effects.length-1;i>=0;i--){ const ef=effects[i]; ef.update(dt); if (ef.life<=0) effects.splice(i,1); }

  for (let ei=enemies.length-1; ei>=0; ei--){
    const e=enemies[ei]; e.update(dt);
    if (e.x + e.width < 0) { enemies.splice(ei,1); continue; }

    if (player.x < e.x+e.width && player.x+player.width > e.x && player.y < e.y+e.height && player.y+player.height > e.y){
      player.takeDamage(); enemies.splice(ei,1); continue;
    }

    for (let pi=projectiles.length-1; pi>=0; pi--){
      const p=projectiles[pi];
      if (p.x < e.x + e.width && p.x > e.x && p.y > e.y && p.y < e.y + e.height){
        e.hp -= weaponStats[p.type].damage;
        if (p.type==='ice'){ e.slowTimer=60; spawnHitParticles(p.x,p.y,'ice'); }
        else if (p.type==='fire'){
          spawnHitParticles(p.x,p.y,'fire');
          enemies.forEach(o=>{ if (o!==e && Math.hypot(o.x-e.x, o.y-e.y)<60) o.hp--; });
        } else { spawnHitParticles(p.x,p.y,'default'); }
        projectiles.splice(pi,1);
        sfxHit.currentTime=0; sfxHit.play();

        if (e.hp<=0){
          spawnExplosion(e.x+e.width/2, e.y+e.height/2);
          dropCollectable(e.x,e.y);
          enemies.splice(ei,1);
          killCount++;
          if(killCount>=20 && !boss) spawnBoss();
          cameraShake=10;
          break;
        }
      }
    }
  }

  if(boss){
    boss.shieldActive = bossSigils.length>0;
    boss.update(dt);
    for (let si=bossSigils.length-1; si>=0; si--){
      const sig=bossSigils[si];
      if (!boss){ bossSigils=[]; break; }
      sig.update(dt);
    }
    if (player.x < boss.x+boss.width && player.x+player.width > boss.x && player.y < boss.y+boss.height && player.y+player.height > boss.y){
      player.takeDamage();
    }
    for (let pi=projectiles.length-1; pi>=0; pi--){
      const p=projectiles[pi];
      let consumed=false;
      for (let si=bossSigils.length-1; si>=0; si--){
        const sig=bossSigils[si];
        const dist=Math.hypot((p.x||0) - sig.x, (p.y||0) - sig.y);
        if (dist < sig.size/2 + 6){
          const dmg = (weaponStats[p.type]?.damage) || 1;
          const destroyed = sig.takeDamage(dmg);
          projectiles.splice(pi,1);
          sfxHit.currentTime=0; sfxHit.play();
          if (destroyed){
            bossSigils.splice(si,1);
            if (bossSigils.length===0){
              boss.shieldActive=false;
              floatTexts.push(new FloatText(window.innerWidth/2 - 110, 100, 'Shield Shattered!', '#ffe6ff'));
              cameraShake = Math.max(cameraShake, 12);
            }
          }
          consumed=true;
          break;
        }
      }
      if (consumed) continue;
      if (p.x < boss.x + boss.width && p.x > boss.x && p.y > boss.y && p.y < boss.y + boss.height){
        if (bossSigils.length>0){
          spawnHitParticles(p.x,p.y,'lightning');
          sfxHit.currentTime=0; sfxHit.play();
          projectiles.splice(pi,1);
          continue;
        }
        boss.hp -= weaponStats[p.type].damage;
        spawnHitParticles(p.x,p.y,'default');
        projectiles.splice(pi,1);
        if (boss.hp<=0){
          const bx=boss.x+boss.width/2, by=boss.y+boss.height/2;
          spawnExplosion(bx, by);
          spawnBlood(bx, by);
          spawnShockwave(bx, by);
          player.bonusShots++;
          boss=null; bossSigils=[]; bossHazards=[];
          bossSpawnTimer = 60*60 + Math.random()*60*60; setWeather(); weatherParticles=[]; cameraShake=20;
          break;
        }
      }
    }
  } else {
    if (bossSpawnTimer<=0) { spawnBoss(); }
    else bossSpawnTimer-=dt;
    if (enemySpawnTimer<=0){ enemies.push(new Enemy()); enemySpawnTimer=90; } else enemySpawnTimer-=dt;
  }

  for(let bi=bossProjectiles.length-1; bi>=0; bi--){
    const b=bossProjectiles[bi]; b.update(dt);
    if (player.x < b.x+b.size && player.x+player.width > b.x && player.y < b.y+b.size && player.y+player.height > b.y){
      player.takeDamage(); bossProjectiles.splice(bi,1); continue;
    }
    if (b.x < -50 || b.x > window.innerWidth+50 || b.y < -50 || b.y > window.innerHeight+50) bossProjectiles.splice(bi,1);
  }

  for (let hi=bossHazards.length-1; hi>=0; hi--){
    const h=bossHazards[hi]; h.update(dt);
    if (h.hitPlayer(player)) player.takeDamage();
    if (h.done) bossHazards.splice(hi,1);
  }

  for (let ci=collectables.length-1; ci>=0; ci--){
    const c=collectables[ci]; c.update(dt);
    if (player.x < c.x+c.size && player.x+player.width > c.x && player.y < c.y+c.size && player.y+player.height > c.y){
      if (c.type==='heart'){ if (player.hp<5) player.hp++; }
      else { player.weapon = c.type; bgHueTimer = 120; }
      sfxPickup.currentTime=0; sfxPickup.play();
      collectables.splice(ci,1);
    }
  }

  if (cameraShake>0) cameraShake-=dt;
}

function draw(){
  const sx = cameraShake ? Math.random()*cameraShake - cameraShake/2 : 0;
  const sy = cameraShake ? Math.random()*cameraShake - cameraShake/2 : 0;
  ctx.save(); ctx.translate(sx,sy);
  ctx.clearRect(0,0,window.innerWidth,window.innerHeight);
  bgObjs.forEach(bg=>bg.draw());
  player.draw();
  projectiles.forEach(p=>p.draw());
  effects.forEach(e=>e.draw());
  enemies.forEach(e=>e.draw());
  if(boss) boss.draw();
  bossSigils.forEach(s=>s.draw());
  bossHazards.forEach(h=>h.draw());
  bossProjectiles.forEach(b=>b.draw());
  collectables.forEach(c=>c.draw());
  drawParticles(frameDt);
  drawWeather();
  for (let i=floatTexts.length-1;i>=0;i--){ const ft=floatTexts[i]; ft.update(frameDt); if (ft.life<=0) floatTexts.splice(i,1); else ft.draw(); }
  ctx.restore();
}

function drawStartScreen(){
  ctx.fillStyle='black'; ctx.fillRect(0,0,window.innerWidth,window.innerHeight);
  ctx.fillStyle='white'; ctx.font='48px sans-serif'; ctx.textAlign='center';
  ctx.fillText('Wizard Carpet Quest', window.innerWidth/2, window.innerHeight/2 - 40);
  ctx.font='24px sans-serif';
  ctx.fillText(gameOver ? 'Game Over — Tap/Press to Restart' : 'Tap/Press Any Key to Start', window.innerWidth/2, window.innerHeight/2 + 20);
}

function loop(t){
  if(!lastTime) lastTime = t;
  const dt = Math.min(2, (t - lastTime) / 16.6667);
  lastTime = t;
  frameDt = dt;
  if (!started || gameOver) drawStartScreen();
  else { update(dt); draw(); }
  requestAnimationFrame(loop);
}
resetGame();
requestAnimationFrame(loop);
</script>
</body>
</html>
