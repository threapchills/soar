<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Wizard Carpet Quest</title>
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no, viewport-fit=cover">
<link rel="icon" type="image/png" href="assets/wizard_shoot.png">
<style>
  :root { --ui-fade: 0.35 }
  html, body { height:100%; }
  body { margin:0; overflow:hidden; background:black; touch-action:none; }
  canvas { display:block; background:black; width:100vw; height:100vh; }

  /* Mobile HUD (hidden on non-touch) */
  .hud { position:fixed; inset:0; pointer-events:none; display:none; }
  .touch .hud { display:block; }
  .stick {
    position: fixed;
    width: 140px; height: 140px; border-radius: 50%;
    background: radial-gradient(circle at 50% 50%, rgba(255,255,255,0.08), rgba(255,255,255,0.02));
    border: 1px solid rgba(255,255,255,0.2);
    pointer-events:auto; opacity: var(--ui-fade);
  }
  .pad {
    position:absolute; left:50%; top:50%; transform:translate(-50%,-50%);
    width: 70px; height:70px; border-radius:50%;
    background: rgba(255,255,255,0.15); border:1px solid rgba(255,255,255,0.3);
  }
  .left-stick { left: 20px; bottom: 24px; }
  .right-stick { right: 20px; bottom: 24px; }
</style>
</head>
<body>
<canvas id="game"></canvas>
<div class="hud" id="hud">
  <div class="stick left-stick" id="stickL"><div class="pad" id="padL"></div></div>
  <div class="stick right-stick" id="stickR"><div class="pad" id="padR"></div></div>
</div>

<script>
/* ========= Canvas & DPI ========= */
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
function resizeCanvas(){
  const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1)); // cap at 2x for perf
  const w = Math.floor(window.innerWidth);
  const h = Math.floor(window.innerHeight);
  canvas.style.width = w + 'px';
  canvas.style.height = h + 'px';
  canvas.width = Math.floor(w * dpr);
  canvas.height = Math.floor(h * dpr);
  ctx.setTransform(dpr,0,0,dpr,0,0); // use CSS pixels as logical units
}
resizeCanvas();
window.addEventListener('resize', resizeCanvas);

/* ========= Input (desktop) ========= */
let keys = {};
let mouse = { x: window.innerWidth/2, y: window.innerHeight/2, down: false };
window.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true, {passive:false});
window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false, {passive:false});
window.addEventListener('mousemove', e => { mouse.x = e.clientX; mouse.y = e.clientY; }, {passive:true});
window.addEventListener('mousedown', () => mouse.down = true, {passive:false});
window.addEventListener('mouseup', () => mouse.down = false, {passive:false});

/* ========= Touch detection & dual sticks ========= */
const isTouch = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
if (isTouch) document.documentElement.classList.add('touch');
const hud = document.getElementById('hud');
const stickL = document.getElementById('stickL'), padL = document.getElementById('padL');
const stickR = document.getElementById('stickR'), padR = document.getElementById('padR');

let leftStick = { active:false, dx:0, dy:0 };
let rightStick = { active:false, dx:0, dy:0 };

function stickBounds(el){ const r = el.getBoundingClientRect(); return {x:r.left + r.width/2, y:r.top + r.height/2, rad: r.width*0.5}; }
function handleStickTouch(e){
  e.preventDefault();
  const touches = e.touches ? Array.from(e.touches) : [];
  leftStick.active = rightStick.active = false; leftStick.dx=leftStick.dy=rightStick.dx=rightStick.dy=0;

  const lb = stickBounds(stickL), rb = stickBounds(stickR);
  touches.forEach(t=>{
    const x=t.clientX, y=t.clientY;
    const dl = Math.hypot(x-lb.x, y-lb.y);
    const dr = Math.hypot(x-rb.x, y-rb.y);
    if (dl < lb.rad) {
      leftStick.active = true;
      const ang = Math.atan2(y-lb.y, x-lb.x);
      const mag = Math.min(1, dl/lb.rad);
      leftStick.dx = Math.cos(ang)*mag;
      leftStick.dy = Math.sin(ang)*mag;
      padL.style.transform = `translate(${(leftStick.dx*lb.rad*0.4)}px, ${(leftStick.dy*lb.rad*0.4)}px)`;
    } else if (dr < rb.rad) {
      rightStick.active = true;
      const ang = Math.atan2(y-rb.y, x-rb.x);
      const mag = Math.min(1, dr/rb.rad);
      rightStick.dx = Math.cos(ang)*mag;
      rightStick.dy = Math.sin(ang)*mag;
      padR.style.transform = `translate(${(rightStick.dx*rb.rad*0.4)}px, ${(rightStick.dy*rb.rad*0.4)}px)`;

      // Aim vector => synthetic mouse
      mouse.x = player ? player.x + Math.cos(ang)*300 : x;
      mouse.y = player ? player.y + Math.sin(ang)*300 : y;
      mouse.down = mag > 0.2; // hold to shoot (deadzone)
    }
  });

  // Map left stick to WSAD booleans
  keys['w'] = leftStick.active && (leftStick.dy < -0.3);
  keys['s'] = leftStick.active && (leftStick.dy >  0.3);
  keys['a'] = leftStick.active && (leftStick.dx < -0.3);
  keys['d'] = leftStick.active && (leftStick.dx >  0.3);

  if (!rightStick.active) { mouse.down = false; padR.style.transform='translate(-50%,-50%)'; }
  if (!leftStick.active)  { padL.style.transform='translate(-50%,-50%)'; }
}
if (isTouch) {
  ['touchstart','touchmove','touchend','touchcancel'].forEach(evt=>{
    window.addEventListener(evt, handleStickTouch, {passive:false});
  });
}

/* ========= Assets ========= */
function loadImage(src) { const img = new Image(); img.src = src; return img; }
const bgLayers = [
  loadImage('assets/bg0.png'), // static sky
  loadImage('assets/bg1.png'),
  loadImage('assets/bg2.png'),
  loadImage('assets/bg3.png')
];
const wizardFly = loadImage('assets/wizard_fly.png');
const wizardShoot = loadImage('assets/wizard_shoot.png');
const enemiesSprites = [
  loadImage('assets/enemy1.png'),
  loadImage('assets/enemy2.png'),
  loadImage('assets/enemy3.png')
];
const orbSprite = loadImage('assets/orb.png');
const heartSprite = loadImage('assets/heart.png');

const song = new Audio('assets/song.ogg'); song.loop = true; song.volume = 0.0;
const sfxShoot = new Audio('assets/shoot.wav');
const sfxHit = new Audio('assets/hit.wav');
const sfxPickup = new Audio('assets/pickup.wav');

/* ========= Game State ========= */
let started=false, gameOver=false, cameraShake=0;
let bgHue=0, bgHueTimer=0;
let dayHue=0, worldBrightness=1, timeOfDay=0, dayCycle=120*60;
let weather='clear', weatherTimer=0, weatherParticles=[], lightningFlash=0;
let player, projectiles, enemies, particles, collectables, effects, floatTexts, enemySpawnTimer, boss, bossProjectiles, bossSpawnTimer, killCount;
let lastTime = 0, frameDt = 1;

const hueMap = { fire: 0, lightning: 220, ice: 180 };
const weaponStats = {
  default:   { cooldown: 15, speed: 10, damage: 1 },
  fire:      { cooldown: 25, speed:  6, damage: 2 },
  lightning: { cooldown: 30, speed:  0, damage: 2 }, // hitscan
  ice:       { cooldown: 22, speed:  8, damage: 1 }
};

/* ========= Start / Music ========= */
function startGame(){
  if (!started) { started=true; fadeInMusic(); resetGame(); }
  else if (gameOver) { resetGame(); }
}
function fadeInMusic(){
  song.currentTime=0;
  song.play().catch(()=>{});
  let vol=0;
  const fade = setInterval(()=>{
    vol += 0.02; song.volume = Math.min(vol, 0.4);
    if (song.volume >= 0.4) clearInterval(fade);
  },100);
}
window.addEventListener('click', startGame, {passive:true});
window.addEventListener('keydown', startGame, {passive:true});
window.addEventListener('touchstart', startGame, {passive:true});

function setWeather(){
  const types=['clear','rain','snow','sand','wind'];
  weather = types[Math.floor(Math.random()*types.length)];
  weatherTimer = 600 + Math.random()*1200;
}

/* ========= Classes ========= */
class Background{
  constructor(img,speed,hueMult=1,baseHue=0){ this.img=img; this.speed=speed; this.x=0; this.hueMult=hueMult; this.baseHue=baseHue; }
  update(dir,dt){
    if (this.speed===0) return; // bg0 static
    this.x -= this.speed * (dir>=0 ? 1 : -1) * dt; // reverse cosmetically when moving left
    const w = window.innerWidth;
    if (this.x <= -w) this.x += w;
    if (this.x >=  w) this.x -= w;
  }
  draw(){
    const w = window.innerWidth, h = window.innerHeight;
    ctx.save();
    const hue = this.baseHue + dayHue + bgHue * this.hueMult;
    ctx.filter = `hue-rotate(${hue}deg) brightness(${worldBrightness})`;
    ctx.drawImage(this.img, this.x, 0, w, h);
    if (this.speed!==0){
      ctx.drawImage(this.img, this.x + w, 0, w, h);
      ctx.drawImage(this.img, this.x - w, 0, w, h);
    }
    ctx.restore();
  }
}

class Player{
  constructor(){
    this.x = window.innerWidth/4;
    this.y = window.innerHeight/2;
    this.width=64; this.height=32;
    this.vx=0; this.vy=0; this.accel=0.4; this.maxSpeed=5;
    this.bob=0; this.flip=false;
    this.hp=5; this.invuln=0;
    this.weapon='default';
    this.cooldownTimer=0;
  }
  update(dt){
    if (this.invuln>0) this.invuln -= dt;
    let tx=0, ty=0;
    if (keys['w']) ty -= this.accel*dt;
    if (keys['s']) ty += this.accel*dt;
    if (keys['a']) { tx -= this.accel*dt; this.flip = true; }
    if (keys['d']) { tx += this.accel*dt; this.flip = false; }
    this.vx = (this.vx + tx) * Math.pow(0.9, dt);
    this.vy = (this.vy + ty) * Math.pow(0.9, dt);
    this.vx = Math.max(-this.maxSpeed, Math.min(this.maxSpeed, this.vx));
    this.vy = Math.max(-this.maxSpeed, Math.min(this.maxSpeed, this.vy));
    this.x += this.vx*dt; this.y += this.vy*dt;

    // Horizontal wrap; vertical clamped
    const halfW=this.width/2, halfH=this.height/2;
    if (this.x < -halfW) this.x = window.innerWidth + halfW;
    if (this.x > window.innerWidth + halfW) this.x = -halfW;
    this.y = Math.max(halfH, Math.min(window.innerHeight - halfH, this.y));

    // bob
    this.bob += 0.05*dt; this.y += Math.sin(this.bob)*0.3*dt;

    // shooting with cooldown
    if (mouse.down && this.cooldownTimer<=0){
      this.shoot();
      this.cooldownTimer = weaponStats[this.weapon].cooldown;
    }
    if (this.cooldownTimer>0) this.cooldownTimer -= dt;
  }
  shoot(){
    sfxShoot.currentTime=0; sfxShoot.play();
    const angle = Math.atan2(mouse.y - this.y, mouse.x - this.x);
    if (this.weapon==='default' || this.weapon==='ice' || this.weapon==='fire'){
      projectiles.push(new Projectile(this.x+this.width/2, this.y, angle, this.weapon));
    } else if (this.weapon==='lightning'){
      effects.push(new LightningEffect(this.x+this.width/2, this.y, angle));
    }
    for (let i=0;i<8;i++) particles.push(makeParticle(this.x+this.width/2, this.y, '255,220,150', 2));
    cameraShake = Math.max(cameraShake,2);
  }
  takeDamage(){ if (this.invuln>0) return; this.hp--; this.invuln=30; if (this.hp<=0) gameOver=true; }
  draw(){
    ctx.save();
    ctx.translate(this.x, this.y);
    if (this.flip){ ctx.scale(-1,1); ctx.translate(-this.width, 0); }
    if (this.invuln%6<3){
      const img = (mouse.down && this.cooldownTimer > weaponStats[this.weapon].cooldown/2) ? wizardShoot : wizardFly;
      ctx.drawImage(img, 0, -this.height/2, this.width, this.height);
    }
    ctx.restore();
    // HP UI
    ctx.fillStyle='red'; ctx.fillRect(20,20, this.hp*30, 10);
    ctx.strokeStyle='white'; ctx.strokeRect(20,20, 5*30, 10);
  }
}

class Projectile{
  constructor(x,y,angle,type){
    this.x=x; this.y=y; this.type=type;
    this.speed=weaponStats[type].speed;
    this.vx=Math.cos(angle)*this.speed;
    this.vy=Math.sin(angle)*this.speed;
    this.size=6; this.life=60;
    this.color = (type==='fire')?'255,120,0':(type==='ice')?'150,200,255':'255,255,150';
  }
  update(dt){
    this.x+=this.vx*dt; this.y+=this.vy*dt; this.life-=dt;
    const trail = makeParticle(this.x, this.y, this.color, 2);
    trail.vx *= 0.2; trail.vy *= 0.2; trail.life = 20;
    particles.push(trail);
  }
  draw(){
    ctx.save(); ctx.globalCompositeOperation='lighter';
    ctx.fillStyle=`rgba(${this.color},0.15)`; ctx.beginPath(); ctx.arc(this.x,this.y,this.size*2.4,0,Math.PI*2); ctx.fill();
    ctx.fillStyle=`rgba(${this.color},1)`; ctx.beginPath(); ctx.arc(this.x,this.y,this.size,0,Math.PI*2); ctx.fill();
    ctx.restore();
  }
}

class LightningEffect{
  constructor(x,y,angle){
    this.x=x; this.y=y; this.angle=angle; this.life=6; this.hitApplied=false;
    this.targets=findLightningTargets(this.x,this.y,this.angle);
  }
  update(dt){
    if (!this.hitApplied){
      this.targets.forEach((t,i)=>{
        if (!t) return;
        const dmg = i===0?2:1;
        t.hp -= dmg;
        spawnHitParticles(t.x+t.width/2, t.y+t.height/2, 'lightning');
        if (t.hp<=0){
          spawnExplosion(t.x+t.width/2, t.y+t.height/2);
          dropCollectable(t.x,t.y);
          enemies.splice(enemies.indexOf(t),1);
          cameraShake=10;
        }
      });
      sfxHit.currentTime=0; sfxHit.play();
      this.hitApplied=true;
    }
    this.life-=dt;
  }
  draw(){
    if (this.targets.length===0) return;
    ctx.save(); ctx.globalCompositeOperation='lighter';
    ctx.strokeStyle='rgba(120,200,255,0.9)'; ctx.lineWidth=2;
    ctx.beginPath(); ctx.moveTo(this.x,this.y);
    this.targets.forEach(t=>{
      if (!t) return;
      const tx=t.x+t.width/2, ty=t.y+t.height/2;
      const seg=6; for (let i=1;i<=seg;i++){
        const p=i/seg;
        const ix=this.x+(tx-this.x)*p + (Math.random()-0.5)*8;
        const iy=this.y+(ty-this.y)*p + (Math.random()-0.5)*8;
        ctx.lineTo(ix,iy);
      }
    });
    ctx.stroke(); ctx.restore();
  }
}

class BossProjectile{
  constructor(x,y,tx,ty){
    this.x=x; this.y=y;
    const ang=Math.atan2(ty-y, tx-x);
    this.vx=Math.cos(ang)*4; this.vy=Math.sin(ang)*4;
    this.size=8;
  }
  update(dt){ this.x+=this.vx*dt; this.y+=this.vy*dt; }
  draw(){ ctx.fillStyle='rgba(255,50,50,1)'; ctx.beginPath(); ctx.arc(this.x,this.y,this.size,0,Math.PI*2); ctx.fill(); }
}

class Boss{
  constructor(type){
    this.type=type;
    this.sprite=enemiesSprites[type];
    this.width=384; this.height=384;
    this.x=window.innerWidth; this.y=window.innerHeight/2 - this.height/2;
    this.hp=200 + type*50;
    this.timer=0; this.vx=0; this.vy=0; this.anim=0;
  }
  update(dt){
    this.timer+=dt; this.anim+=dt;
    if(this.type===0){
      this.x -= 1.5*dt;
      this.y += Math.sin(this.anim*0.03*60)*2*dt;
      if(this.timer>=120){ enemies.push(new Enemy()); this.timer=0; }
    } else if(this.type===1){
      if(this.timer>=180){ this.vx=-6; this.vy=(player.y-this.y)/60; this.timer=0; }
      this.x += this.vx*dt; this.y += this.vy*dt; this.vx*=Math.pow(0.98,dt); this.vy*=Math.pow(0.98,dt);
    } else if(this.type===2){
      this.x -= 0.8*dt;
      this.y += Math.sin(this.anim*0.04*60)*3*dt;
      if(this.timer>=90){ bossProjectiles.push(new BossProjectile(this.x, this.y+this.height/2, player.x, player.y)); this.timer=0; }
    }
    this.y = Math.max(0, Math.min(window.innerHeight - this.height, this.y));
  }
  draw(){ ctx.drawImage(this.sprite, this.x, this.y, this.width, this.height); }
}

class Enemy{
  constructor(){
    this.sprite = enemiesSprites[Math.floor(Math.random()*enemiesSprites.length)];
    this.width=96; this.height=96;

    // Spawn and baseline
    this.x = window.innerWidth + 50;
    this.y = Math.random()*(window.innerHeight - this.height);
    this.baseY = this.y;
    this.drift = (Math.random()*0.5 + 0.2) * (Math.random()<0.5 ? -1 : 1);

    // Movement/HP
    this.baseSpeed = 2 + Math.random()*1.5; // constant world speed
    this.hp = 3;

    // Zig-zag variety
    this.waveOffset = Math.random()*Math.PI*2;
    this.waveSpeed  = 0.005 + Math.random()*0.02;
    this.waveAmp    = 10 + Math.random()*110; // 10–120px amplitude

    this.slowTimer=0;
  }
  update(dt){
    const spd = this.slowTimer>0 ? this.baseSpeed*0.5 : this.baseSpeed;
    if (this.slowTimer>0) this.slowTimer-=dt;
    this.x -= spd*dt;

    // drift baseline up/down
    this.baseY += this.drift*dt;
    if (this.baseY < 0 || this.baseY > window.innerHeight - this.height) this.drift *= -1;

    // layered wobble around drifting baseline
    const t = perfNow();
    const wobble = Math.sin(t * this.waveSpeed + this.waveOffset) * this.waveAmp;
    const wobble2 = Math.sin(t * this.waveSpeed * 1.7 + this.waveOffset * 1.5) * this.waveAmp * 0.25;
    this.y = this.baseY + wobble + wobble2;

    // Stay in vertical bounds
    this.y = Math.max(0, Math.min(window.innerHeight - this.height, this.y));
  }
  draw(){ ctx.drawImage(this.sprite, this.x, this.y, this.width, this.height); }
}

class Collectable{
  constructor(x,y,type){ this.x=x; this.y=y; this.type=type; this.size=24; this.floatOffset=Math.random()*Math.PI*2; }
  update(dt){ this.x -= 2*dt; this.floatOffset += 0.05*dt; }
  draw(){
    const dy = Math.sin(this.floatOffset)*4;
    if (this.type==='heart') ctx.drawImage(heartSprite, this.x, this.y+dy, this.size, this.size);
    else { ctx.save(); ctx.filter=`hue-rotate(${hueMap[this.type]}deg)`; ctx.drawImage(orbSprite, this.x, this.y+dy, this.size, this.size); ctx.restore(); }
  }
}

class FloatText{
  constructor(x,y,text,color){ this.x=x; this.y=y; this.text=text; this.color=color; this.life=40; }
  update(dt){ this.y -= 0.5*dt; this.life-=dt; }
  draw(){ ctx.fillStyle=this.color; ctx.font='16px sans-serif'; ctx.fillText(this.text,this.x,this.y); }
}

/* ========= Particles ========= */
function spawnExplosion(x,y){
  for(let i=0;i<28;i++) particles.push(makeParticle(x,y,(Math.random()<0.6)?'255,120,0':'255,60,0',5));
}
function spawnHitParticles(x,y,type='default'){
  let color='255,0,0', size=4;
  if (type==='fire'){ color='255,120,0'; size=5; }
  if (type==='ice'){ color='160,220,255'; size=3; }
  if (type==='lightning'){ color='120,200,255'; size=3; }
  for(let i=0;i<32;i++) particles.push(makeParticle(x,y,color,size));
}
function makeParticle(x,y,color,size){
  return { x,y, vx:(Math.random()-0.5)*6, vy:(Math.random()-0.5)*6, life:24+Math.random()*12, size, color };
}
function drawParticles(dt){
  ctx.save(); ctx.globalCompositeOperation='lighter';
  for (let i=particles.length-1;i>=0;i--){
    const p=particles[i]; p.x+=p.vx*dt; p.y+=p.vy*dt; p.life-=dt;
    const a=Math.max(0,p.life/36);
    ctx.fillStyle=`rgba(${p.color},${a})`;
    ctx.beginPath(); ctx.arc(p.x,p.y,p.size,0,Math.PI*2); ctx.fill();
    if (p.life<=0) particles.splice(i,1);
  }
  ctx.restore();
}

function updateWeather(dt){
  if((weatherTimer-=dt)<=0) setWeather();
  const w=window.innerWidth, h=window.innerHeight;
  if(weather==='rain'){
    for(let i=0;i<5*dt;i++) weatherParticles.push({x:Math.random()*w, y:-10, vx:-2+Math.random(), vy:10+Math.random()*4, type:'rain', life:h});
  } else if(weather==='snow'){
    for(let i=0;i<2*dt;i++) weatherParticles.push({x:Math.random()*w, y:-10, vx:-1+Math.random()*2, vy:2+Math.random()*1, type:'snow', life:h});
  } else if(weather==='sand'){
    for(let i=0;i<4*dt;i++) weatherParticles.push({x:Math.random()*w, y:Math.random()*h, vx:-3-Math.random()*2, vy:Math.random()-0.5, type:'sand', life:200});
  } else if(weather==='wind'){
    for(let i=0;i<dt;i++) if(Math.random()<0.3) weatherParticles.push({x:Math.random()*w, y:Math.random()*h, vx:-2-Math.random()*2, vy:Math.random()-0.5, type:'leaf', rot:Math.random()*Math.PI, life:200});
  }
  if((weather==='rain' || weather==='sand') && Math.random()<0.002*dt) lightningFlash=5;
  for(let i=weatherParticles.length-1;i>=0;i--){
    const p=weatherParticles[i]; p.x+=p.vx*dt; p.y+=p.vy*dt; p.life-=dt;
    if(p.type==='rain') p.vy+=0.1*dt;
    if(p.life<=0 || p.y>h+20 || p.x<-20 || p.x>w+20) weatherParticles.splice(i,1);
  }
  lightningFlash = Math.max(0, lightningFlash - dt);
}

function drawWeather(){
  ctx.save();
  weatherParticles.forEach(p=>{
    if(p.type==='rain'){
      ctx.strokeStyle='rgba(160,160,255,0.6)';
      ctx.beginPath(); ctx.moveTo(p.x,p.y); ctx.lineTo(p.x+p.vx*2,p.y+p.vy*2); ctx.stroke();
    } else if(p.type==='snow'){
      ctx.fillStyle='rgba(255,255,255,0.8)';
      ctx.beginPath(); ctx.arc(p.x,p.y,2,0,Math.PI*2); ctx.fill();
    } else if(p.type==='sand'){
      ctx.fillStyle='rgba(194,178,128,0.7)';
      ctx.fillRect(p.x,p.y,2,2);
    } else if(p.type==='leaf'){
      ctx.fillStyle='rgba(200,150,50,0.8)';
      ctx.save(); ctx.translate(p.x,p.y); ctx.rotate(p.rot||0); ctx.fillRect(-3,-1,6,2); ctx.restore();
      p.rot += 0.05*frameDt;
    }
  });
  ctx.restore();
  if(lightningFlash>0){ ctx.fillStyle=`rgba(255,255,255,${lightningFlash/10})`; ctx.fillRect(0,0,window.innerWidth,window.innerHeight); }
}

/* ========= Helpers ========= */
function perfNow(){ return (performance || Date).now ? (performance.now()/1000) : (Date.now()/1000); }
function findLightningTargets(px,py,angle){
  return enemies
    .map(e=>({e, d: Math.hypot(e.x-px, e.y-py)}))
    .filter(o=>o.d<500)
    .sort((a,b)=>a.d-b.d)
    .slice(0,2)
    .map(o=>o.e);
}
function dropCollectable(x,y){
  const roll=Math.random();
  if (roll<0.2) collectables.push(new Collectable(x,y,'heart'));
  else if (roll<0.6){
    const types=['fire','lightning','ice'];
    collectables.push(new Collectable(x,y, types[Math.floor(Math.random()*types.length)]));
  }
}

function spawnBoss(){
  boss = new Boss(Math.floor(Math.random()*enemiesSprites.length));
  weather = 'rain';
  weatherTimer = 1200;
  weatherParticles = [];
  lightningFlash = 8;
  killCount = 0;
}

/* ========= Backgrounds ========= */
const layerHueOffsets=[0, Math.random()*60-30, Math.random()*60-30, Math.random()*60-30];
const bgObjs = [
  new Background(bgLayers[0], 0, 0, layerHueOffsets[0]),
  new Background(bgLayers[1], 0.2, 0.5, layerHueOffsets[1]),
  new Background(bgLayers[2], 0.5, 1.0, layerHueOffsets[2]),
  new Background(bgLayers[3], 1.0, 1.2, layerHueOffsets[3])
];

/* ========= Core Loop ========= */
function resetGame(){
  player = new Player();
  projectiles = [];
  enemies = [];
  collectables = [];
  effects = [];
  floatTexts = [];
  particles = [];
  weatherParticles = [];
  bossProjectiles = [];
  enemySpawnTimer = 0;
  cameraShake = 0;
  bgHue = 0; bgHueTimer = 0;
  dayHue = 0; worldBrightness = 1; timeOfDay = 0;
  lightningFlash = 0; setWeather();
  boss = null; bossSpawnTimer = 60*60 + Math.random()*60*60;
  killCount = 0;
  gameOver = false;
}

function update(dt){
  const dir = player && player.vx < -0.1 ? -1 : 1;
  if (bgHueTimer>0){ bgHue = (bgHue + 2*dt) % 360; bgHueTimer -= dt; } else { bgHue = 0; }

  timeOfDay = (timeOfDay + dt) % dayCycle;
  const p = timeOfDay / dayCycle;
  worldBrightness = 0.5 + 0.5*Math.sin(p*2*Math.PI);
  dayHue = 20*Math.sin(p*2*Math.PI);

  updateWeather(dt);
  bgObjs.forEach(bg=>bg.update(dir, dt));

  player.update(dt);

  for (let i=projectiles.length-1;i>=0;i--){ const pj=projectiles[i]; pj.update(dt); if (pj.life<=0) projectiles.splice(i,1); }
  for (let i=effects.length-1;i>=0;i--){ const ef=effects[i]; ef.update(dt); if (ef.life<=0) effects.splice(i,1); }

  for (let ei=enemies.length-1; ei>=0; ei--){
    const e=enemies[ei]; e.update(dt);
    if (e.x + e.width < 0) { enemies.splice(ei,1); continue; }

    if (player.x < e.x+e.width && player.x+player.width > e.x && player.y < e.y+e.height && player.y+player.height > e.y){
      player.takeDamage(); enemies.splice(ei,1); continue;
    }

    for (let pi=projectiles.length-1; pi>=0; pi--){
      const p=projectiles[pi];
      if (p.x < e.x + e.width && p.x > e.x && p.y > e.y && p.y < e.y + e.height){
        e.hp -= weaponStats[p.type].damage;
        if (p.type==='ice'){ e.slowTimer=60; spawnHitParticles(p.x,p.y,'ice'); }
        else if (p.type==='fire'){
          spawnHitParticles(p.x,p.y,'fire');
          enemies.forEach(o=>{ if (o!==e && Math.hypot(o.x-e.x, o.y-e.y)<60) o.hp--; });
        } else { spawnHitParticles(p.x,p.y,'default'); }
        projectiles.splice(pi,1);
        sfxHit.currentTime=0; sfxHit.play();

        if (e.hp<=0){
          spawnExplosion(e.x+e.width/2, e.y+e.height/2);
          dropCollectable(e.x,e.y);
          enemies.splice(ei,1);
          killCount++;
          if(killCount>=25 && !boss) spawnBoss();
          cameraShake=10;
          break;
        }
      }
    }
  }

  if(boss){
    boss.update(dt);
    if (player.x < boss.x+boss.width && player.x+player.width > boss.x && player.y < boss.y+boss.height && player.y+player.height > boss.y){
      player.takeDamage();
    }
    for (let pi=projectiles.length-1; pi>=0; pi--){
      const p=projectiles[pi];
      if (p.x < boss.x + boss.width && p.x > boss.x && p.y > boss.y && p.y < boss.y + boss.height){
        boss.hp -= weaponStats[p.type].damage;
        spawnHitParticles(p.x,p.y,'default');
        projectiles.splice(pi,1);
        if (boss.hp<=0){
          spawnExplosion(boss.x+boss.width/2, boss.y+boss.height/2);
          boss=null; bossSpawnTimer = 60*60 + Math.random()*60*60; setWeather(); weatherParticles=[]; cameraShake=20;
          break;
        }
      }
    }
  } else {
    if (bossSpawnTimer<=0) { spawnBoss(); }
    else bossSpawnTimer-=dt;
    if (enemySpawnTimer<=0){ enemies.push(new Enemy()); enemySpawnTimer=90; } else enemySpawnTimer-=dt;
  }

  for(let bi=bossProjectiles.length-1; bi>=0; bi--){
    const b=bossProjectiles[bi]; b.update(dt);
    if (player.x < b.x+b.size && player.x+player.width > b.x && player.y < b.y+b.size && player.y+player.height > b.y){
      player.takeDamage(); bossProjectiles.splice(bi,1); continue;
    }
    if (b.x < -50 || b.x > window.innerWidth+50 || b.y < -50 || b.y > window.innerHeight+50) bossProjectiles.splice(bi,1);
  }

  for (let ci=collectables.length-1; ci>=0; ci--){
    const c=collectables[ci]; c.update(dt);
    if (player.x < c.x+c.size && player.x+player.width > c.x && player.y < c.y+c.size && player.y+player.height > c.y){
      if (c.type==='heart'){ if (player.hp<5) player.hp++; }
      else { player.weapon = c.type; bgHueTimer = 120; }
      sfxPickup.currentTime=0; sfxPickup.play();
      collectables.splice(ci,1);
    }
  }

  if (cameraShake>0) cameraShake-=dt;
}

function draw(){
  const sx = cameraShake ? Math.random()*cameraShake - cameraShake/2 : 0;
  const sy = cameraShake ? Math.random()*cameraShake - cameraShake/2 : 0;
  ctx.save(); ctx.translate(sx,sy);
  ctx.clearRect(0,0,window.innerWidth,window.innerHeight);
  bgObjs.forEach(bg=>bg.draw());
  player.draw();
  projectiles.forEach(p=>p.draw());
  effects.forEach(e=>e.draw());
  enemies.forEach(e=>e.draw());
  if(boss) boss.draw();
  bossProjectiles.forEach(b=>b.draw());
  collectables.forEach(c=>c.draw());
  drawParticles(frameDt);
  drawWeather();
  for (let i=floatTexts.length-1;i>=0;i--){ const ft=floatTexts[i]; ft.update(frameDt); if (ft.life<=0) floatTexts.splice(i,1); else ft.draw(); }
  ctx.restore();
}

function drawStartScreen(){
  ctx.fillStyle='black'; ctx.fillRect(0,0,window.innerWidth,window.innerHeight);
  ctx.fillStyle='white'; ctx.font='48px sans-serif'; ctx.textAlign='center';
  ctx.fillText('Wizard Carpet Quest', window.innerWidth/2, window.innerHeight/2 - 40);
  ctx.font='24px sans-serif';
  ctx.fillText(gameOver ? 'Game Over — Tap/Press to Restart' : 'Tap/Press Any Key to Start', window.innerWidth/2, window.innerHeight/2 + 20);
}

function loop(t){
  if(!lastTime) lastTime = t;
  const dt = Math.min(2, (t - lastTime) / 16.6667);
  lastTime = t;
  frameDt = dt;
  if (!started || gameOver) drawStartScreen();
  else { update(dt); draw(); }
  requestAnimationFrame(loop);
}
resetGame();
requestAnimationFrame(loop);
</script>
</body>
</html>
