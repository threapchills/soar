<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Wizard Carpet Infinite Scroll</title>
<style>
  body {
    margin: 0;
    overflow: hidden;
    background: black;
  }
  canvas {
    display: block;
    background: black;
  }
</style>
</head>
<body>
<canvas id="game"></canvas>
<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

let keys = {};
let mouse = { x: 0, y: 0, down: false };

window.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);
window.addEventListener('mousemove', e => {
    mouse.x = e.clientX;
    mouse.y = e.clientY;
});
window.addEventListener('mousedown', e => { mouse.down = true; });
window.addEventListener('mouseup', e => { mouse.down = false; });

function loadImage(src) {
    const img = new Image();
    img.src = src;
    return img;
}

// Load assets
const bgLayers = [
    loadImage('assets/bg0.png'),
    loadImage('assets/bg1.png'),
    loadImage('assets/bg2.png'),
    loadImage('assets/bg3.png')
];
const wizardFly = loadImage('assets/wizard_fly.png');
const wizardShoot = loadImage('assets/wizard_shoot.png');
const enemiesSprites = [
    loadImage('assets/enemy1.png'),
    loadImage('assets/enemy2.png'),
    loadImage('assets/enemy3.png')
];

// Sounds
const song = new Audio('assets/song.ogg');
song.loop = true;
song.volume = 0.4;
song.play();

const sfxShoot = new Audio('assets/shoot.wav');
const sfxHit = new Audio('assets/hit.wav');

class Background {
    constructor(img, speed) {
        this.img = img;
        this.speed = speed;
        this.x = 0;
    }
    update() {
        if (this.speed === 0) return;
        this.x -= this.speed;
        if (this.x <= -canvas.width) {
            this.x = 0;
        }
    }
    draw() {
        ctx.drawImage(this.img, this.x, 0, canvas.width, canvas.height);
        if (this.speed !== 0) {
            ctx.drawImage(this.img, this.x + canvas.width, 0, canvas.width, canvas.height);
        }
    }
}

class Player {
    constructor() {
        this.x = canvas.width / 4;
        this.y = canvas.height / 2;
        this.width = 64;
        this.height = 32;
        this.speed = 4;
        this.bob = 0;
        this.flip = false;
        this.shootCooldown = 0;
    }
    update() {
        if (keys['w']) this.y -= this.speed;
        if (keys['s']) this.y += this.speed;
        if (keys['a']) { this.x -= this.speed; this.flip = true; }
        if (keys['d']) { this.x += this.speed; this.flip = false; }

        // Bobbing
        this.bob += 0.05;
        this.y += Math.sin(this.bob) * 0.3;

        // Shooting
        if (mouse.down && this.shootCooldown <= 0) {
            this.shoot();
            this.shootCooldown = 15; // frames between shots
        }
        if (this.shootCooldown > 0) this.shootCooldown--;
    }
    shoot() {
        const angle = Math.atan2(mouse.y - this.y, mouse.x - this.x);
        projectiles.push(new Projectile(this.x + this.width/2, this.y, angle));
        sfxShoot.currentTime = 0;
        sfxShoot.play();
    }
    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        if (this.flip) {
            ctx.scale(-1, 1);
            ctx.translate(-this.width, 0);
        }
        const img = (mouse.down && this.shootCooldown > 10) ? wizardShoot : wizardFly;
        ctx.drawImage(img, 0, -this.height/2, this.width, this.height);
        ctx.restore();
    }
}

class Projectile {
    constructor(x, y, angle) {
        this.x = x;
        this.y = y;
        this.speed = 10;
        this.vx = Math.cos(angle) * this.speed;
        this.vy = Math.sin(angle) * this.speed;
        this.size = 6;
        this.life = 60;
    }
    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.life--;
    }
    draw() {
        let grd = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.size);
        grd.addColorStop(0, 'rgba(255,255,150,1)');
        grd.addColorStop(1, 'rgba(255,100,0,0)');
        ctx.fillStyle = grd;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fill();
    }
}

class Enemy {
    constructor() {
        this.sprite = enemiesSprites[Math.floor(Math.random()*enemiesSprites.length)];
        this.width = 96;
        this.height = 96;
        this.x = canvas.width + 50;
        this.y = Math.random() * (canvas.height - this.height);
        this.speed = 2 + Math.random()*1.5;
        this.hp = 3;
    }
    update() {
        this.x -= this.speed;
    }
    draw() {
        ctx.drawImage(this.sprite, this.x, this.y, this.width, this.height);
    }
}

let player = new Player();
let projectiles = [];
let enemies = [];
let enemySpawnTimer = 0;

const bgObjs = [
    new Background(bgLayers[0], 0),
    new Background(bgLayers[1], 0.2),
    new Background(bgLayers[2], 0.5),
    new Background(bgLayers[3], 1)
];

function update() {
    bgObjs.forEach(bg => bg.update());
    player.update();

    projectiles.forEach((p, i) => {
        p.update();
        if (p.life <= 0) projectiles.splice(i,1);
    });

    enemies.forEach((e, ei) => {
        e.update();
        if (e.x + e.width < 0) enemies.splice(ei,1);
        // Collision with projectiles
        projectiles.forEach((p, pi) => {
            if (p.x < e.x + e.width &&
                p.x > e.x &&
                p.y > e.y &&
                p.y < e.y + e.height) {
                e.hp--;
                projectiles.splice(pi,1);
                sfxHit.currentTime = 0;
                sfxHit.play();
                if (e.hp <= 0) enemies.splice(ei,1);
            }
        });
    });

    if (enemySpawnTimer <= 0) {
        enemies.push(new Enemy());
        enemySpawnTimer = 120; // spawn every 2 seconds
    } else {
        enemySpawnTimer--;
    }
}

function draw() {
    ctx.clearRect(0,0,canvas.width,canvas.height);
    bgObjs.forEach(bg => bg.draw());
    player.draw();
    projectiles.forEach(p => p.draw());
    enemies.forEach(e => e.draw());
}

function loop() {
    update();
    draw();
    requestAnimationFrame(loop);
}
loop();

window.addEventListener('resize', () => {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
});
</script>
</body>
</html>
